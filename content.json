{"meta":{"title":"阿木的博客","subtitle":"","description":"","author":"Jason Lee","url":"http://ulemony.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-02-09T02:09:39.000Z","updated":"2023-02-09T02:10:34.000Z","comments":true,"path":"categories/index.html","permalink":"http://ulemony.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-02-09T02:10:51.000Z","updated":"2023-02-09T02:11:19.000Z","comments":true,"path":"tags/index.html","permalink":"http://ulemony.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库表设计","slug":"数据库表设计","date":"2025-07-23T15:41:11.000Z","updated":"2025-07-24T09:30:24.277Z","comments":true,"path":"posts/da3ed1b.html","link":"","permalink":"http://ulemony.github.io/posts/da3ed1b.html","excerpt":"如何根据需求设计数据库表1.流程理解清楚需求 –&gt; 根据需求分析需要几张表 –&gt;分析每张表需要哪些字段 –&gt; 每个表之间的关系，需要怎么关联 –&gt; 建表 对象和对象之间的关系是什么，如果是一对多，需要两张表；多对多，需要三张表，其中一个关系表维护这两个对象之间的关系","text":"如何根据需求设计数据库表1.流程理解清楚需求 –&gt; 根据需求分析需要几张表 –&gt;分析每张表需要哪些字段 –&gt; 每个表之间的关系，需要怎么关联 –&gt; 建表 对象和对象之间的关系是什么，如果是一对多，需要两张表；多对多，需要三张表，其中一个关系表维护这两个对象之间的关系 2.表设计注意事项 按照表规范命名，建表的时候必须有七个字段：cr_time、cr_id、up_time、up_id、rm_time、rm_id、removed 一张表的字段不要太多，如果太多考虑分成两个表 选择合适的字段类型、字段大小，能用整型的话不用字符型，如果数据量不大，该字段存储的数据类型不确定，可以使用字符类型，使得对存储内容兼容性更好 建表的时候最好加上字段注释和表注释 3.一些经验3.1 分库分库原则：每个子系统对应一个数据库 注意：在数据强一致的场景则涉及到数据库分布式事务 3.2分表 从主功能逻辑抽离主要几张表 根据功能补充表 检查多对多关系 3.3 冗余字段 3.4 视图视图能简化后端程序的SQL语句，如用户前台、管理员后台都需要显示热门博客，如果使用视图，就无需在多个接口维护多个复杂的SQL语句 12--根据简单SQL查询热门博客列表select * from v_hot 3.5 命名规范 数据库名：与系统名相同，如user、shop 表名：t_开头，如 t_blog、t_label, 如果是中间表，则结合两个表名 t_bloglabel 视图名： v_ 开头，如 v_hot, v_rank 字段名： 表名开头，如blog_id、label_id 外键：与原来名字相同，如所有的博客id都为blog_id，如果引用多个相同外键，则用$标记 如resource_id$1、resource_id$2 链接 http://ulemony.github.io/posts/da3ed1b.html","categories":[{"name":"Database","slug":"Database","permalink":"http://ulemony.github.io/categories/Database/"}],"tags":[{"name":"databas design","slug":"databas-design","permalink":"http://ulemony.github.io/tags/databas-design/"}]},{"title":"MySQL基础","slug":"MySQL基础","date":"2025-06-06T11:16:36.000Z","updated":"2025-07-24T09:30:09.245Z","comments":true,"path":"posts/bce68613.html","link":"","permalink":"http://ulemony.github.io/posts/bce68613.html","excerpt":"mysql1. 存储引擎对比 对比项 InnoDB MyISAM 事务支持 ✅ 支持（ACID），支持事务的四种隔离级别 ❌ 不支持事务 锁机制 行级锁 + 多种锁（意向锁、间隙锁等） 表级锁 并发能力 高并发性能好 并发性能差，写时锁表 外键支持 ✅ 支持外键 ❌ 不支持外键 崩溃恢复能力 ✅ 强（支持崩溃恢复、Redo&#x2F;Undo Log） ❌ 弱，崩溃后易数据损坏 MVCC 支持 ✅ 支持（多版本并发控制） ❌ 不支持 全文索引 ✅ 支持（MySQL 5.6+） ✅ 支持（较早） 索引结构 聚簇索引（主键与数据在一起） 非聚簇索引（索引与数据分离） 存储文件 .ibd 或共享表空间 .MYD（数据） + .MYI（索引） 表行统计 估算值（快速但不准） 精确计数（慢） 表空间大小 通常较大 通常较小 删除数据后空间 不会自动收缩（可用 OPTIMIZE） 可重用空间 使用场景 事务系统、高并发、数据一致性要求高 静态数据查询为主、读多写少 默认引擎（5.5+） ✅ 是 ❌ 否 2.Explain语句结果各字段分别表示什么123456EXPLAIN SELECT name FROM employees WHERE age = 30;| id | select_type | table | partitions | type | possible\\_keys | key | key_len | ref | rows | filtered | Extra || -- | ------------ | --------- | ---------- | ---- | -------------- | -------- | -------- | ----- | ---- | -------- | ----------- || 1 | SIMPLE | employees | NULL | ref | idx\\_age | idx\\_age | 5 | const | 3 | 100.00 | Using index |","text":"mysql1. 存储引擎对比 对比项 InnoDB MyISAM 事务支持 ✅ 支持（ACID），支持事务的四种隔离级别 ❌ 不支持事务 锁机制 行级锁 + 多种锁（意向锁、间隙锁等） 表级锁 并发能力 高并发性能好 并发性能差，写时锁表 外键支持 ✅ 支持外键 ❌ 不支持外键 崩溃恢复能力 ✅ 强（支持崩溃恢复、Redo&#x2F;Undo Log） ❌ 弱，崩溃后易数据损坏 MVCC 支持 ✅ 支持（多版本并发控制） ❌ 不支持 全文索引 ✅ 支持（MySQL 5.6+） ✅ 支持（较早） 索引结构 聚簇索引（主键与数据在一起） 非聚簇索引（索引与数据分离） 存储文件 .ibd 或共享表空间 .MYD（数据） + .MYI（索引） 表行统计 估算值（快速但不准） 精确计数（慢） 表空间大小 通常较大 通常较小 删除数据后空间 不会自动收缩（可用 OPTIMIZE） 可重用空间 使用场景 事务系统、高并发、数据一致性要求高 静态数据查询为主、读多写少 默认引擎（5.5+） ✅ 是 ❌ 否 2.Explain语句结果各字段分别表示什么123456EXPLAIN SELECT name FROM employees WHERE age = 30;| id | select_type | table | partitions | type | possible\\_keys | key | key_len | ref | rows | filtered | Extra || -- | ------------ | --------- | ---------- | ---- | -------------- | -------- | -------- | ----- | ---- | -------- | ----------- || 1 | SIMPLE | employees | NULL | ref | idx\\_age | idx\\_age | 5 | const | 3 | 100.00 | Using index | 字段解释： 字段名 含义 id 一个select对应一个id，如果是一个select的join操作，会有两个相同id。如果有子查询id会增加，如果能转join的子查询会优化成join。 select_type 查询类型，如 SIMPLE（简单查询）、PRIMARY、SUBQUERY 等。 table 当前访问的表名或别名。 partitions 如果用到分区表，这里会显示所使用的分区；没有分区则为 NULL。 type 连接类型（访问方式），反映性能的关键字段（见下方类型说明）。 possible_keys 查询可能使用的索引列表（优化器认为可用）。 key 实际使用的索引。如果为 NULL，表示未使用索引。 key_len 实际使用索引的长度（字节数）。表示索引利用了多少列。 ref 使用索引进行等值查询时与索引进行比较的对象（常为常量或列）。 rows MySQL 预估扫描的行数（越小越好）。 filtered 过滤后保留的百分比（估算值），与 rows 一起判断数据过滤情况。 Extra 附加信息，例如是否用到临时表、排序，是否用到索引等。 2.1 type常见值说明 type 值 含义说明 system 表仅有一行（系统表） const 索引唯一匹配一行（如主键或唯一键） eq_ref 多表连接中，使用主键或唯一索引 ref 使用普通索引等值匹配（如 WHERE age = 30） range 使用索引范围扫描（如 BETWEEN、&gt;、&lt;） index 扫描整个索引（不访问数据行） ALL 全表扫描 2.2 Extra常见值说明 Extra 值 含义说明 Using index 覆盖索引（只用索引就能获取数据） Using where 使用了 WHERE 条件进行过滤 Using temporary 使用了临时表（如排序、分组时） Using filesort 使用文件排序（不能用索引排序） NULL 没有额外操作 3.Mysql主从同步原理3.1同步流程主库（Master）写 binlog 主库执行完一个事务后，会把操作记录写入 binlog（如 insert、update 等 DML 操作）。 从库（Slave）IO线程读 binlog 从库启动后，会开启一个 IO 线程 去连接主库的 binlog dump 线程，将主库的 binlog 日志拉到自己本地，并写入 relay log。 从库 SQL线程执行 relay log 从库的 SQL 线程 读取 relay log 的内容，并在本地重放（执行相同 SQL），以达到主从一致。 3.2 同步策略 异步复制，master不管slave，只管自己写binlog，slave异步去同步，这种新能最好，但是一致性最差。 半同步复制，事务提交要求n个slave收到日志才算提交成功，当n设置为全部slave节点就是同步复制了。 全同步复制，事务提交要求全部的slave收到日志才算提交成功 4.为什么使用了索引，还是慢查询场景1: 慢SQL的原因是没命中索引实时分析： 慢SQL 在慢查询中，最多的一条语句是 1SELECT * FROM `white_user` WHERE `user_id`=? AND `status`=? AND `level`=? AND `type`=? LIMIT ?,?; 表结构 执行计划 由执行计划的key看到没有用到索引 解决办法：创建索引 1alter table `white_user` add `idx_user_id_status_level_type`(`user_id`,`status`,`level`,`type`); 优化后统计： 场景2:慢SQL的原因是命中了，但是Using filesort查询商家的退款订单列表且按倒叙排序 执行计划 Using filesort 文件排序比较慢，一般在order by的时候出现 部分表结构 解决办法：用到索引的同时，也不要进行文件排序，而是进行create_time的排序 1alter table `refund_cuser` add index `idx_buser_id_createtime`(`buser_id`,`create_time`); 通过执行计划发现已经没有了using filesort 优化后统计 链接 http://ulemony.github.io/posts/bce68613.html","categories":[{"name":"Database","slug":"Database","permalink":"http://ulemony.github.io/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://ulemony.github.io/tags/MySQL/"}]},{"title":"锁和事务","slug":"锁和事务","date":"2025-06-04T09:22:26.000Z","updated":"2025-07-24T09:30:13.252Z","comments":true,"path":"posts/be3c61be.html","link":"","permalink":"http://ulemony.github.io/posts/be3c61be.html","excerpt":"InnoDB 存储引擎的锁的算法Record lock单个行记录的锁，直接锁定某行记录的索引记录，通常用于唯一索引或主键索引上，当使用精确的查询条件例如id&#x3D;1时会使用记录锁 1SELECT * FROM users WHERE id = 5 FOR UPDATE; 锁住主键为5的行","text":"InnoDB 存储引擎的锁的算法Record lock单个行记录的锁，直接锁定某行记录的索引记录，通常用于唯一索引或主键索引上，当使用精确的查询条件例如id&#x3D;1时会使用记录锁 1SELECT * FROM users WHERE id = 5 FOR UPDATE; 锁住主键为5的行 Gap lock间隙锁，锁定一个范围，不包括记录本身 形式是左开右开（left_record,right_record），在RR级别 为了解决幻读问题 例子：表中有age索引记录24, 26, 30, 34 执行语句 1SELECT * FROM employees WHERE age BETWEEN 27 AND 29 FOR UPDATE; 这时查询没有命中任何记录（因为 27~29 不存在）。 所以 InnoDB 会加一个 Gap Lock 锁住 26 和 30 之间的间隙。 (26, 30) ← 这就是 Gap Lock 执行语句 1SELECT * FROM employees WHERE age &gt; 25 FOR UPDATE; 加锁（24，+∞） 执行语句 1SELECT * FROM employees WHERE age =28 FOR UPDATE; 因为28不存在，为了防止后续幻读，在就近区间加锁（26，30） 执行语句 1SELECT * FROM employees WHERE age =26 FOR UPDATE; 只会锁住age&#x3D;26这一行数据 执行语句 1SELECT * FROM employees WHERE age &gt; 26 and age &lt; 32 FOR UPDATE; 命中的记录age&#x3D;30 锁住的区间（26，30]、（30，34] 间隙锁和临键锁在一起 Next-key lock也叫临键锁，record+gap 锁定一个范围，包含记录本身 形式是左开右闭区间(prev_key, current_key],MYSQL默认级别是RR、默认上临键锁 例子：表中有age索引记录24, 26, 30, 34 执行语句 1SELECT * FROM employees WHERE age = 30 FOR UPDATE; 加锁的实际范围 (26, 30] 修改age&#x3D;26不受影响，因为没有加record lock 插入新的age&#x3D;26会被阻塞，因为gap被锁 在B+树中… 24 → 26 → 30 … 这意味着新记录age&#x3D;26要插在「现有的 age &#x3D; 26」记录 的前或后（根据主键二级排序） ⚠️ 也就是：插入点落在 (26, 30) 的 gap 中 —— 而不是你以为的 26 本身！而（24，26）这个区间已经上了gap lock导致无法插入 执行语句 1SELECT * FROM employees WHERE age BETWEEN 26 AND 29 FOR UPDATE; 命中记录age&#x3D;26 加锁情况如下 区间 为什么被锁 (24, 26) 是 26 这个 Next-Key 的左间隙 26 是命中记录，必须加 Record Lock (26, 30) 是“命中范围内但没有记录”的间隙锁 Intention Locks意向锁本质是一种表级锁，但不是真正锁住数据的锁，而是表示“对某些行加锁”的意图 类型：意向共享锁IS、意向排他锁IX 会话a 12BEGIN;SELECT * FROM employees WHERE id = 1 FOR UPDATE; 对id&#x3D;1 的行加了排他锁X，MYSQL会在该表上加一个意向排他锁IX 会话b 1LOCK TABLE employees READ; 会尝试对整个表加一个共享锁S 这与会话a的IX冲突导致会话b阻塞 意向锁是自动加的 行级锁操作 表级意向锁类型 SELECT ... LOCK IN SHARE MODE 意向共享锁（IS） SELECT ... FOR UPDATE 意向排他锁（IX） INSERT &#x2F; UPDATE &#x2F; DELETE 意向排他锁（IX） 意向锁和真正的锁区别 类型 作用范围 是否锁具体数据 加锁目标 行锁（S&#x2F;X） 行级别 是 具体某一行记录 表锁（S&#x2F;X） 表级别 是 整张表 意向锁 表级别 否 表结构上的“意图” 查看锁 使用mysql8版本 1SELECT * FROM performance_schema.data_locks; 事务的基本特性和隔离级别事务的四大特性ACID事务是一组要么全部成功，要么全部失败的数据库操作，具备以下特性 特性 含义 A - 原子性 (Atomicity) 事务是最小执行单位，操作要么都成功，要么都失败，不可能只执行一部分。 用于保证事务不可分割。 C - 一致性 (Consistency) 事务执行前后，数据处于一致状态（满足所有业务&#x2F;约束条件）。 例如扣款和加款必须一致。 I - 隔离性 (Isolation) 多个事务并发执行时，相互之间不能互相干扰，中间状态不可见。 D - 持久性 (Durability) 一旦事务提交，结果永久保存，即使系统崩溃也不会丢失。 通常靠日志机制（如 redo log）实现。 事务隔离级别 隔离级别 能否读到未提交数据？ 会有不可重复读？ 会有幻读？ 1. Read Uncommitted（读未提交） ✅是 ✅是 ✅是 2. Read Committed（读已提交） ❌否 ✅是 ✅是 3. Repeatable Read（可重复读）（MySQL默认） ❌否 ❌否 ✅是（但MySQL通过间隙锁防止幻读） 4. Serializable（可串行化） ❌否 ❌否 ❌否（加表锁，性能最低） 脏读： 一个事务读取了另外一个事务尚未提交的数据。例如事务a读取账户余额，此时事务b修改账户余额但还未有提交，后面因某些原因rollback了操作，那么事务a读取到的数据是不准确的 不可重复读： 一个事务两次查询到的数据不一致，可能是其他事务更新了该数据 幻读：在一个事务中，两次查询符合条件的记录数不一致，可能是因为在两次查询的过程中，其他事务插入了新的几行数据 ACID靠什么保证A原子性靠Undo Log保证，当执行事务时，InnoDB会记录Undo Log，用于出错时回滚之前的修改，事务实行失败或者ROLLBACK，就根据Undo Log来撤销对数据页的修改 C一致性靠其他三大特性进行保证，同时数据库层面的约束例如主键、唯一索引、外键也助于保证一致性 I隔离性 由多版本并发控制MVCC和锁机制保证 D持久性由Redo Log和磁盘刷写策略保证，mysql修改数据同时会把修改写入到Redo Log并刷盘，如果系统崩溃，MYSQL重启时根据Redo Log恢复数据 MVCC在每一行数据都会有两个隐藏字段trx_id和roll_pointer，trx_id是当前事务有写操作才申请的自增id roll_pointer：每次对记录修改的时候，都会把老版本写入到Undo Log中，roll_pointer指向了上一个版本的位置 字段 说明 trx_id 最后一次修改该行的事务 ID roll_pointer 指向 Undo Log（撤销日志）的指针，保存旧版本数据 Readview它是MVCC的核心组件之一，是快照读的“时间快照”，可以用来判断一个trx_id是已经提交还是正在运行的。包含了以下四个字段 字段 含义 m_ids 当前系统中活跃事务的 ID 列表（未提交） min_trx_id m_ids 中最小事务 ID max_trx_id 当前系统中尚未分配的下一个事务 ID creator_trx_id 创建当前 Read View 的事务 ID 判断过程： 访问数据，获取数据中的事务id 1.如果trx_id &lt; min_trx_id，说明是已经提交的事务，数据可以访问 2.如果trx_id ≥ max_trx_id ，说明是未来提交的事务，数据不可以访问 3.如果min_trx_id ≤ trx_id &lt; max_trx_id，先判断是否&#x3D;creator_trx_id如果是，说明是自己改的，可以访问， 否则再判断是不是处于m_ids，如果是说明事务未提交，数据不可访问，否则就是已经提交的事务，数据可以访问 如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断 可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对 该事务完全不可见，查询结果就不包含该记录。 例如有一条数据 age = 30，它被多次修改，形成了一个版本链： 1234记录最新版本：[age=34, trx_id=104] ---&gt; [age=32, trx_id=102] ---&gt; [age=30, trx_id=100] ↑ ↑ Undo2 Undo1 假如当前在事务id&#x3D;105中执行快照读，ReadView如下 1234m_ids = [104]min_trx_id = 104max_trx_id = 106creator_trx_id = 105 现在要读取这条记录，那么从版本链的开头进行判断 版本 trx_id 判断 是否可见 age&#x3D;34 104 trx_id ∈ m_ids ⇒ 活跃事务未提交 ❌ 不可见 age&#x3D;32 102 trx_id &lt; min_trx_id，且不在 m_ids ✅ 可见 ✅ 所以读取 age &#x3D; 32 已提交读的隔离级别下，每一次查询的时候都会生成一个独立的Readview而可重复读，则在第一次读的时候生成Readview，之后都是复用之前的Readview 当前读和快照读依赖Readview的读取又叫做快照读，特点： 非锁定读取不加锁； 读的是事务开始时的数据快照 ；使用MVCC 依赖Undo Log和ReadView ；默认在可重复读或读已提交隔离级别下启用 例如 1234-- 在一个事务中START TRANSACTION;SELECT * FROM employees WHERE age = 30; 如果此时有其他事务修改了 age = 30 的行，该 SELECT 仍然读到的是当前事务开始时那一刻的版本。 典型语句： SELECT（无 FOR UPDATE 或 LOCK IN SHARE MODE） SELECT 语句默认就是快照读 当前读，特点： 读取的是行的最新版本（真实数据）。 会对读取的行加锁（共享锁或排他锁）。 能看到其他事务提交后的最新数据。 如果遇到未提交的数据，可能会阻塞，直到数据可用。 例如 123START TRANSACTION;SELECT * FROM employees WHERE age = 30 FOR UPDATE; 会加上排他锁，阻塞其他修改该行的事务。读取的是最新数据，确保数据不会被其他人修改。 典型语句： SELECT … FOR UPDATESELECT … LOCK IN SHARE MODE UPDATE、INSERT、DELETE 都属于当前读 链接 http://ulemony.github.io/posts/be3c61be.html","categories":[{"name":"Database","slug":"Database","permalink":"http://ulemony.github.io/categories/Database/"}],"tags":[{"name":"事务","slug":"事务","permalink":"http://ulemony.github.io/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"索引","slug":"索引","date":"2025-02-24T15:20:30.000Z","updated":"2025-07-24T09:30:18.159Z","comments":true,"path":"posts/df9a61f7.html","link":"","permalink":"http://ulemony.github.io/posts/df9a61f7.html","excerpt":"索引基础索引的基本原理索引的核心思想是通过为表中的列创建额外的数据结构，来加速查询过程 索引分类常见的索引类型：主键索引、唯一索引、普通索引、全文索引、组合索引","text":"索引基础索引的基本原理索引的核心思想是通过为表中的列创建额外的数据结构，来加速查询过程 索引分类常见的索引类型：主键索引、唯一索引、普通索引、全文索引、组合索引 主键索引把某个列设置为主键的时候，该列就是主键索引，每个表只能有一个主键索引，主键列的值是唯一的，不能为NULL 123456CREATE TABLE users ( id INT PRIMARY KEY auto_increment, -- 主键索引 name VARCHAR(50) not null default &#x27;&#x27;, age INT); 如果创建表时没有主键索引，可以在创建之后添加 1alter table table_name add primary key (column_name) 唯一索引唯一索引和主键索引类似，保证索引列中的每个值是唯一的。但唯一索引允许存在 NULL 值，而且每个表可以有多个唯一索引 123456CREATE TABLE employees ( id INT PRIMARY KEY auto_increment, email VARCHAR(100) UNIQUE, -- 唯一索引 name VARCHAR(50)); 如果创建表时没有唯一索引，可以创建后追加 123ALTER TABLE table_nameADD CONSTRAINT constraint_name UNIQUE (column_name);--constraint_name 指约束名，可以自定义 或者 12ALTER TABLE usersADD UNIQUE (email); 普通索引不要求列中的值唯一，表中可以有多个普通索引 123456CREATE TABLE products ( id INT PRIMARY KEY, name VARCHAR(100), price DECIMAL(10, 2), INDEX idx_price(price) -- 普通索引); 全文索引通常用于对长文本字段进行复杂的搜索，例如查询特定的单词; 在MYSQL5.6之前只有MyISAM存储引擎支持全文索引，MYSQL5.6之后InnoDB存储引擎也支持全文索引 123456CREATE TABLE articles ( id INT PRIMARY KEY, title VARCHAR(100), content TEXT, FULLTEXT INDEX idx_fulltext(content) -- 全文索引); 也可以在创建表后追加全文索引 12ALTER TABLE table_nameADD FULLTEXT INDEX index_name (column_name); 可以利用MATCH和AGAINST来进行高效的全文搜索 1SELECT * FROM articles WHERE MATCH(content) AGAINST(&#x27;database&#x27;); 组合索引由多个列组成的索引；遵循“最左前缀”原则 1234567CREATE TABLE orders ( id INT PRIMARY KEY, customer_id INT, order_date DATE, amount DECIMAL(10, 2), INDEX idx_customer_order(customer_id, order_date) -- 组合索引); 也可以在创建表后追加组合索引 12ALTER TABLE table_nameADD INDEX index_name (column1, column2, ...); 查询时可以利用这两个列来查询 1SELECT * FROM orders WHERE customer_id = 101 AND order_date BETWEEN &#x27;2023-01-01&#x27; AND &#x27;2023-12-31&#x27;; 查看表的索引 12SHOW INDEX FROM 表名; 索引机制添加完索引后，MySQL一般通过BTREE算法生成一个索引文件，在查询数据库时，找到索引文件进行遍历，找到相应的键从而获取数据 创建索引产生的索引文件会占用磁盘空间，在增删改查时会对索引文件进行修改，性能会有所下降 索引存储数据结构哈希表以键值对存储的数据结构，只要输入key就可以找到对应的value，等值查询高效，但不支持范围查询。在MySQL中，Memory存储引擎的默认索引类型就是哈希索引 二叉查找树当数据量大时，二叉树的树高会比较大，需要多次读取磁盘耗费时间 B树（Balance Tree）图中的p节点为指向子节点的指针，每个节点称为页，页就是磁盘快，mysql中数据读取的基本单位是页 B树和二叉树相比，每个节点存储量更多的键值和数据，而且拥有更多的子节点，高度很低，B树查找读取磁盘的次数很少，提高了查找效率 假如要查找id&#x3D;29的用户，查找流程如下： 1.找到根节点也就是页1，判断29在17和35之间，选取指针p2找到页3 2.把29和页3中的键值比较，29在26和30之间，选取指针p2找到页8 3.将29和页8的键值比较，有匹配的的键值29，完成查找 B+树 B+树的非叶节点不存储数据，仅存储键值，所有数据存储在叶子节点，而且数据是按照顺序排列的，这使得B+树范围查找、排序查找、分组查找以及去重查找变得很简单。 如果B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000x1000x1000&#x3D;10亿个数据。一般根节点常驻内存，查找10个数据只需要2次磁盘IO B+树页之间通过双向链表连接，叶子节点中的数据通过单向链表连接 在Innodb存储引擎中，B+树索引是 聚簇索引，在MYISAM中，B+树索引的叶子节点不存储数据，而是数据的地址，属于非聚簇索引 聚簇索引和非聚簇索引在MySQL中，B+树按存储方式可分为聚簇索引和非聚簇索引 聚簇索引在InnoDB中，主键索引就是聚簇索引，即使不创建主键，系统也会主动创建隐式主键，以主键作为B+树索引的键值而构建的B+树索引为聚簇索引，叶子节点存储了行数据 当执行sql语句：select * from user where id&gt;&#x3D;18 and id &lt;40，对应的数据查找过程（以上图为例） 不需要从磁盘读取数据，直接从内存中读取根节点也就是页1，在页1中找到键值18，从而根据指针p2定位到页3 从磁盘中读取页3并放入内存中，在页3中找到键值18，根据指针p1定位到页8 从磁盘中读取页8并放入内存中，页中的数据是通过单向链表进行连接，且键值按照顺序存放，可以根据二分查找法定位到键值18 因为是范围查找而去所有数据存放于叶子节点，且有序排列，可以对页8的键值遍历查询，可以一直找到键值为22的数据，此时页8的数据被全部遍历，由于页之间通过双向链表连接，可通过页8的指针定位到页9进行数据查询，一直到页12，发现41大于40不满足条件，查找终止 非聚簇索引以主键之外的列值作为键值构建的B+树索引称之为非聚簇索引，也叫辅助索引（二级索引） 和聚簇索引的区别在于非聚簇索引的叶子节点不存储表中的数据，而是该列对应的主键，数据表和索引表是分开存储的。查询时先找到主键，再用主键到聚簇索引中进行查找数据，这个过程称为 回表。 当执行sql语句执行 select * from user where name &#x3D; ‘jim’，查找流程如下 从内存读取根节点页1，根据指针p1定位到页2 根据页2中的指针p2定位到页6 找到索引对应的值jim，获取主键20 到主键索引中根据主键20 获取对应的数据 如果使用了覆盖索引，则不需要回表，直接通过辅助索引就可以查到需要的数据，覆盖索引的前提是查询列要被所建的索引覆盖 例如对于数据表 employees，包含 id、name 和 age 三列： 12345CREATE TABLE employees ( id INT PRIMARY KEY, name VARCHAR(100), age INT); 可以为name 和age 创建一个复合索引 12CREATE INDEX idx_name_age ON employees (name, age); 当执行查询 SELECT name, age FROM employees WHERE name &#x3D; ‘Alice’; idx_name_age 索引中已经包含了 name 和 age 两个列，因此这个查询可以完全通过索引来获取结果，不需要访问实际的数据库 相关名词最左匹配原则在创建一个复合索引时，查询条件必须从复合索引的最左列开始，且不能跳过中间的任何列，才能有效使用索引 12345678CREATE TABLE employees ( id INT PRIMARY KEY, name VARCHAR(100), age INT);CREATE INDEX idx_name_age ON employees (name, age); 索引 idx_name_age 是由 name 列和 age 列构成的复合索引，索引顺序是 **name -&gt; age**。 完全匹配索引顺序 1SELECT * FROM employees WHERE name = &#x27;Alice&#x27; AND age = 30; 查询首先按索引中的最左边的列 name 进行匹配，接着按 age 列进行匹配，符合复合索引的列顺序。 部分匹配索引 1SELECT * FROM employees WHERE name = &#x27;Alice&#x27;; 跳过中间列的查询 1SELECT * FROM employees WHERE age = 30 AND name = &#x27;Alice&#x27;; 不符合最左匹配索引原则：在复合索引idx_name_age中，name列排在age列前面，查询条件没有从最左的列name开始匹配，而是从age开始 索引下推过滤条件直接在索引层面进行应用，只有符合条件的数据会被返回，减少了不必要的回表操作 假设employess表 12345678CREATE TABLE employees ( id INT PRIMARY KEY, name VARCHAR(100), age INT, salary DECIMAL(10, 2), hire_date DATE); 为age和salary创建了复合索引 1CREATE INDEX idx_age_salary ON employees(age, salary); 当执行查询 1SELECT * FROM employees WHERE age &gt; 30 AND salary &gt; 5000; 如果没有索引下推，mysql会扫描索引idx_age_salary 找到所有符合age&gt;30的记录，然后回表到employees表中查找salary&gt;5000的记录 最终返回符合age&gt;30 和salary&gt;5000的记录 当有索引下推，在扫描索引时不仅刷选age&gt;30的记录，还会同时应用salary&gt;5000的条件，这样只有同时符合这两个条件的数据才会被返回 索引的使用原则不适合建索引的情况 表记录太少 区分度不高的字段例如性别不适合建索引 where条件中用不到的字段不适合建立索引 经常插入、删除、修改的表要减少索引 text、image等类型不适合建立索引 mysql能估计出全表扫描比使用索引更快的时候，不使用索引 参与计算的列不适合建立索引 索引失效场景 使用LIKE模糊匹配 左边有通配符 1SELECT * FROM users WHERE name LIKE &#x27;%abc&#x27;; -- 索引失效 %在前，MYSQL无法通过索引定位前缀，只能全表扫描 优化：改成右匹配 1SELECT * FROM users WHERE name LIKE &#x27;abc%&#x27;; -- 可使用索引 在索引列上使用函数或表达式 1SELECT * FROM users WHERE YEAR(birthdate) = 1990; -- 索引失效 对索引列使用了函数 YEAR()，使得不能使用索引。 优化： 1SELECT * FROM users WHERE birthdate &gt;= &#x27;1990-01-01&#x27; AND birthdate &lt; &#x27;1991-01-01&#x27;; 隐式类型转换 1SELECT * FROM users WHERE phone = 1234567890; -- 索引失效 phone 是字符串类型，但用数字进行比较，发生隐式类型转换。 优化： 1SELECT * FROM users WHERE phone = &#x27;1234567890&#x27;; ​ OR查询没有全部字段都使用索引 1SELECT * FROM users WHERE username = &#x27;tom&#x27; OR age = 18; -- 索引失效 username 有索引，但 age 没有，MySQL 无法对整体使用索引。 优化：确保所有OR条件字段都有索引，或者用UNION 拆开 123SELECT * FROM users WHERE username = &#x27;tom&#x27;UNIONSELECT * FROM users WHERE age = 18; 组合索引不满足最左匹配原则 12-- 组合索引：(username, age)SELECT * FROM users WHERE age = 18; -- 索引失效 没有从最左列username开始匹配 优化： 1SELECT * FROM users WHERE username = &#x27;tom&#x27; AND age = 18; -- 使用索引 使用 !=、&lt;&gt;、NOT IN、NOT LIKE 1SELECT * FROM users WHERE age != 18; -- 索引失效 这些操作无法快速过滤，只能回表或全表扫描 优化：可以考虑业务侧改写逻辑 使用 IS NULL 和 IS NOT NULL（部分情况） 1SELECT * FROM users WHERE deleted_at IS NOT NULL; -- 可能失效 IS NOT NULL 一般不能使用索引，IS NULL 可部分使用索引。 优化：尽量避免此类查询影响性能 使用范围查询后再使用排序 1SELECT * FROM users WHERE age &gt; 18 ORDER BY username; -- 可能失效 范围条件 age &gt; 18 会让后面的索引 username 排序失效。 优化：排序字段应在范围字段之前，或使用覆盖索引等方式优化。 索引重复率太高 即使有索引，如果字段的区分度低（如性别字段只有 “男&#x2F;女”），优化器可能认为全表扫描更快。 1SELECT * FROM users WHERE gender = &#x27;男&#x27;; -- 索引可能不被使用 优化：如果表大并且经常查这个字段，可考虑使用 联合索引 或 添加统计列优化逻辑。 覆盖索引被打破 12-- 如果索引是 (username, age)，但查询了其他字段SELECT * FROM users WHERE username = &#x27;tom&#x27; AND age = 18; -- 不能使用覆盖索引 使用精确字段 1SELECT username, age FROM users WHERE username = &#x27;tom&#x27; AND age = 18; 链接 http://ulemony.github.io/posts/df9a61f7.html","categories":[{"name":"Database","slug":"Database","permalink":"http://ulemony.github.io/categories/Database/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://ulemony.github.io/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"JVM垃圾回收 GC","slug":"JVM垃圾回收-GC","date":"2025-01-20T08:10:23.000Z","updated":"2025-02-24T11:27:09.945Z","comments":true,"path":"posts/935a6b06.html","link":"","permalink":"http://ulemony.github.io/posts/935a6b06.html","excerpt":"GC 如何判断对象可回收引用计数法每个对象有一个引用计数器，每当有一个引用指向它，计数器 +1；引用断开时，计数器 -1； 当计数器为 0 时，表示对象不再被引用，可以被回收。 缺点：无法处理循环引用的问题。例如，两个对象相互引用，但不再被外部引用，这种情况下计数器不会为 0。","text":"GC 如何判断对象可回收引用计数法每个对象有一个引用计数器，每当有一个引用指向它，计数器 +1；引用断开时，计数器 -1； 当计数器为 0 时，表示对象不再被引用，可以被回收。 缺点：无法处理循环引用的问题。例如，两个对象相互引用，但不再被外部引用，这种情况下计数器不会为 0。 可达性分析法GC Roots作为对象起始点，向下搜索，如果一个对象到GC Roots没有引用链则对象不可用，可以被回收 常见的GC Roots： 虚拟机栈中引用的对象，例如局部变量、临时变量 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 示例代码 12345678910111213141516171819202122232425262728293031public class GCRootsDemo &#123; private static GCRootsDemo staticField; // 静态成员变量 (GC Roots) private GCRootsDemo instanceField; // 实例成员变量 (非GC Roots) private static final int ARRAY_SIZE = 3; public static void main(String[] args) &#123; // 1. 创建本地变量（GC Roots） GCRootsDemo localVar = new GCRootsDemo(); // 2. 静态成员变量引用（GC Roots） staticField = new GCRootsDemo(); // 3. localVar 的实例成员变量引用（非GC Roots） localVar.instanceField = new GCRootsDemo(); // 4. 数组对象的引用（数组本身是GC Roots） GCRootsDemo[] array = new GCRootsDemo[ARRAY_SIZE]; for (int i = 0; i &lt; ARRAY_SIZE; i++) &#123; array[i] = new GCRootsDemo(); // 每个元素指向一个新对象 &#125; // 打破某些引用链 array[1] = null; // 元素1指向的对象可以回收 localVar = null; // localVar不再指向对象 staticField = null; // staticField不再指向对象 // 主动触发GC System.gc(); &#125;&#125; 引用关系图 初始状态 1234567891011GC Roots: 非GC Roots引用: ┌──────────────┐ ┌───────────────┐ │ localVar │ ───────► │ GCRootsDemo │ │ staticField │ ───────► │ GCRootsDemo │ │ array │ ───────► │ GCRootsDemo[] │ └──────────────┘ └───────────────┘ │ │ │ ▼ ▼ ▼ Object Object Object (array[1] 被置 null后断开) 断开引用后 1234567891011GC Roots: 非GC Roots引用: ┌──────────────┐ ┌───────────────┐ │ localVar (X) │ │ GCRootsDemo │ │ staticField(X│ │ │ │ array │ ───────► │ GCRootsDemo[] │ └──────────────┘ └───────────────┘ │ │ ▼ ▼ Object Object (array[1] 不可达) GC回收分析 存活的对象： array 本身及其 array[0] 和 array[2] 指向的对象。 array[1] 被置为 null，对应的对象会被GC。 可回收对象： localVar 和 staticField 被置为 null，它们之前引用的对象变得不可达，成为垃圾。 array[1] 的对象由于被置为 null，没有其他路径可达，也会被回收。 四种引用强引用最常见的引用类型，在引用期间不会被垃圾回收器回收，例如Object obj&#x3D;new Object(); 示例代码 123456public class StrongReferenceDemo &#123; public static void main(String[] args) &#123; MyObject obj = new MyObject(); // 强引用 // obj对象会一直存在，直到 obj 变量超出作用域或被显式置为 null &#125;&#125; 软引用在系统内存充足的情况下，软引用对象不会被回收；但在系统内存不足时，垃圾回收器会尽量回收软引用指向的对象 需要用SoftReference类来实现 示例代码 12345678910111213import java.lang.ref.SoftReference;public class SoftReferenceDemo &#123; public static void main(String[] args) &#123; MyObject obj = new MyObject(); SoftReference&lt;MyObject&gt; softRef = new SoftReference&lt;&gt;(obj); // obj 不再是强引用了 obj = null; // 在内存充足的情况下，softRef.get()可以返回对象 System.out.println(softRef.get()); &#125;&#125; 适用场景： 缓存： 例如，图片缓存、数据库查询结果缓存等。软引用能够使缓存对象在内存不足时被自动回收，避免了缓存导致的内存泄漏。 临时数据： 对一些临时对象使用软引用，当内存不够时允许对象被回收。 弱引用弱引用指向的对象在垃圾回收时会被回收，不管系统内存是否充足。即当一个对象只有弱引用时，它会在下一次垃圾回收时被回收。 需要WeakReference类来实现 示例代码 1234567891011121314import java.lang.ref.WeakReference;public class WeakReferenceDemo &#123; public static void main(String[] args) &#123; MyObject obj = new MyObject(); WeakReference&lt;MyObject&gt; weakRef = new WeakReference&lt;&gt;(obj); obj = null; // 删除强引用 System.gc(); // 显式调用垃圾回收器 // 因为没有强引用，weakRef.get() 返回 null System.out.println(weakRef.get()); &#125;&#125; 适用场景： 事件监听： 当监听器对象使用弱引用时，监听器可以在没有强引用时被GC回收，而不影响事件的正常传递。 不可恢复的临时对象： 用弱引用来表示可以被回收的缓存对象。例如：图像、临时数据等，系统内存不足时会被回收。 虚引用虚引用是最弱的引用类型，几乎不影响垃圾回收器的回收行为。虚引用主要用于在对象被垃圾回收器回收后进行一些清理操作。虚引用不能通过 get() 方法获取对象，它的作用是跟踪对象的回收过程。需要PhantomReference来实现 不能通过它直接访问对象，常与 ReferenceQueue 配合使用。 示例代码 12345678910111213141516import java.lang.ref.PhantomReference;import java.lang.ref.ReferenceQueue;public class PhantomReferenceDemo &#123; public static void main(String[] args) throws InterruptedException &#123; MyObject obj = new MyObject(); ReferenceQueue&lt;MyObject&gt; queue = new ReferenceQueue&lt;&gt;(); PhantomReference&lt;MyObject&gt; phantomRef = new PhantomReference&lt;&gt;(obj, queue); obj = null; // 删除强引用 System.gc(); // 显式调用垃圾回收器 // 此时对象已经被GC回收，但虚引用仍然存在 System.out.println(queue.remove()); // 在GC后，会将虚引用加入到ReferenceQueue &#125;&#125; 适用场景： 资源清理：例如，在Java中引用了本地（native）资源（如文件句柄、数据库连接、socket连接等），虚引用可以帮助在对象回收时执行清理工作。 底层资源管理：如关闭操作系统的文件句柄、数据库连接等，在对象即将被回收时，可以通过虚引用确保相关资源被释放。 垃圾回收算法标记-清除 Mark-Sweep首先标记出所有需要回 收的对象，在标记完成后，统一回收掉所有被标记的对象 缺点：执行效率不稳定；产生大量的内存碎片 标记-复制 Copying将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉 优点：避免了内存碎片 缺点：可用内存是原来的一半，浪费空间 在Young GC时采用标记复制算法 ![Young GC](Young GC.png) 如此反复交换，当年龄达到16时，仍然存活的对象移至老年区 标记-整理 Mark-Compact标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可 回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存 缺点：如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用 程序才能进行，也就是STW （Stop The World） 算法 内存碎片化 性能 空间利用率 适用场景 标记-清除 存在碎片 一般 高 对空间要求较高的场景 标记-复制 无碎片 快 低 新生代，短生命周期对象较多 标记-整理 无碎片 较慢 高 老年代，长生命周期对象较多 垃圾收集器 收集器 类型 新生代&#x2F;老年代 算法 优势 劣势 Serial 单线程 新生代 标记-复制 简单高效，适合单核环境 暂停时间长 ParNew 多线程 新生代 标记-复制 支持多核环境，与 CMS 兼容 暂停时间依然较长 Parallel Scavenge 多线程 新生代 标记-复制 吞吐量优先，自动调优 暂停时间较长 Serial Old 单线程 老年代 标记-整理 简单高效，与 Parallel Scavenge 兼容 暂停时间长 Parallel Old 多线程 老年代 标记-整理 高吞吐量，与 Parallel Scavenge 搭配 暂停时间长 CMS 多线程 老年代 标记-清除 低停顿，适合低延迟应用 内存碎片化，GC 开销高 G1 多线程 新生代+老年代 标记-整理 分区回收，低停顿，内存整理 实现复杂，调优较难 Serial收集器垃圾回收时，只有一个线程工作，所有其他线程暂停（”Stop The World”）。 ParNew收集器实质上是Serial收集器的多线程并行版本 Parallel Scavenge收集器目标则是达到一个可控制的吞吐量(Throughput) ![Parallel Old收集器](Parallel Old收集器.png) Serial Old收集器Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，与 Parallel Scavenge 收集器配合，适用于高吞吐量场景。 ![Parallel Old收集器](Parallel Old收集器.png) CMS收集器是一种以获取最短回收停顿时间为目标的收集器 4步过程： 初始标记（CMS initial mark） - 只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 并发标记（CMS concurrent mark）-和用户线程一起工作，不需要暂停工作线程。标记全部可达对象。 重新标记（CMS remark）- 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正。 并发清除（CMS concurrent sweep） - 清除GCRoots不可达对象，和用户线程一起工作，不需要暂停工作线程。基于标记结果，直接清理对象 并发清理后大量内存被释放，但并没有被压缩 G1收集器堆划分将整个内存堆区域分成大小相同的子区域Region，默认2048个分区；每个分区按需在年轻代和老年代之间切换 每 个Region的 大 小 可 以 通 过 参 数 -XX: G1HeapRegionSize 设 定，取值范围为1MB~32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中 ![G1 堆划分](G1 堆划分-7623678.png) RSet（Remembered Set） 记录了其它 Region 对当前 Region 的引用情况，这样回收某个Region时，不需要执行全堆扫描，只需扫描它的 RSet 就可以找到外部引用，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况 Card Table 它将每个 Region 进一步划分为更小的固定大小单位（通常 512 字节），称之为Card。Card的作用是标记某个内存区域中的对象是否有跨Region的引用。 CardTable是一个数据结构，通常是一个数组，其中的每个元素对应一个Card。每个Card用于跟踪其代表的内存块中的引用对象是否跨越了不同的Region。在垃圾回收时CardTable用于快速查询某个内存区域内的对象是否还有跨Region的引用。如果某个区域的对象引用了其他区域的对象，相关的Card就会标记为“脏”（Dirty），即该Card区域有跨Region的引用。CardTable保存了这些脏标记，垃圾回收时G1会根据CardTable中脏标记的Card来检查哪些Region中的对象可能会被其他Region引用，从而避免扫描整个堆 在回收时，Card Table 帮助 Rset 确定哪些区域可能存在引用，从而减少扫描工作。 写屏障 更新Card状态使用了写屏障技术，当写屏障捕获到跨对象的引用时，会将涉及的Card标记为脏，同时将他们放入到一个脏队列中，JVM会通过单独的线程，定期读取脏队列中的数据，更新记忆集。 HashTable RSet（Remembered Set） 的底层实现中采用了 HashTable（或者类似的哈希结构）来组织和存储数据。 一个Region可能有多个线程在并发修改，因此也可能会并发修改 RSet。为避免冲突，G1垃圾回收器进一步把 RSet 划分成了多个 HashTable，每个线程都在各自的 HashTable 里修改。最终，从逻辑上来说，RSet 就是这些 HashTable 的集合。哈希表是实现 RSet 的一种常见方式 HashTable 的 Key 是别的 Region 的起始地址，Value是一个集合，里面的元素是Card Table的Index。它记录哪些其他 Region 对当前 Region 中的对象有引用 假设有三个 Region：Region A、Region B 和 Region C，它们的引用关系如下： Region A 的对象 a1 引用了 Region B 的对象 b1，a1位于卡片Card X。 Region A 的对象 a2 引用了 Region C 的对象 c1，a2位于卡片Card Z。 Region B 的 RSet： 记录 Region A 对它的引用。 HashTable 中可能的键值对结构 12Key: Region AValue: [Card X, Card Y] （标记 Region A 中的哪些卡片对 Region B 有引用） Region C 的 RSet： 记录 Region A 对它的引用。 HashTable 中可能的键值对结构 123Key: Region AValue: [Card Z] （标记 Region A 中的某个卡片对 Region C 有引用） Young GC采用了三种关键技术：RSet、CardTable、写屏障 当G1触发Yong GC时，只会扫描年轻代区域的对象，从GC Root根对象出发，很容易扫描出年轻代的对象及引用的其他年轻代的对象。 如果年轻代的对象被老年代对象引用了，通过RememberSet来解决，回收器会将RSet中的对象也加入到GC Root中，有效避免年轻代的对象被错误回收 ![Young GC in G1](Young GC in G1.png) ![End of Young GC with G1](End of Young GC with G1.png) Young Generation内存空间由不连续的区域组成，使得在需要时可以轻松调整大小 在Young GC时会STW，应用线程会停止 Young GC使用多个线程并行完成 存活对象会被复制到另外的survivor regions或old generation regions Mixed GC初始标记 标记出所有 GC Roots 节点以及直接可达的对象，此阶段会STW，但耗时很短 并发标记 空区域被标记为X 将会在重新标记阶段被删除 并发阶段采用三色标记法 三色标记法 白色：表示该对象还没被访问过,可能是垃圾，尚未标记为存活；初始时，所有对象默认为白色 灰色：表示对象已经被访问过，但它引用对象还未被访问，该对象是存活的，需要进一步扫描其引用的对象，是一个过渡颜色，最终都会被标记为黑色 黑色：该对象和其引用的对象都被扫描过，且这些对象都标记为存活，不再需要进一步扫描 三色标记法缺点：漏标 在remark过程中，黑色指向了白色，如果不对黑色重新扫描，则会漏标，导致白色D对象被当作没有新引用指向从而回收掉 产生漏标问题的两个条件： 1.黑色对象指向了白色对象 2.灰色对象指向白色对象的引用消失 解决漏标问题，打破连个条件之一即可 跟踪黑指向白的增加 incremental update；增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS采用该方法 记录灰指向白的消失 SATB snapshot at the beginning： 关注引用的删除，当灰指向白消失时，要把这个引用推到GC的堆栈，保证白还能被扫描到。G1采用该方法，是因为SATB可以和RSet相配合，RSet记录了其他对象指向自己的引用，当灰色指向白色消失时，引用会push到堆盏，由于RSet存在，不需要扫描整个堆去查找指向白色的引用，效率比较高 SATB 意为“开始时快照”，核心思想是在并发标记的过程中创建堆内存的快照，确保即使应用线程修改了引用关系，回收器也能正确标记对象 SATB的主要步骤： 1.初始快照的创建 ​ 在并发标记的开始阶段，会记录标记时刻的快照，也就是GC Roots的对象快照图 2.并发标记过程 ​ 遍历快照中的对象，灰色对象会递归扫描它们引用的对象，直到所有存活对象都变成黑色 3.对象引用变更处理 ​ 在并发标记阶段，对象的引用可能会被修改。G1使用写屏障来捕捉引用的变化，将引用的对象放入一个待处理的SATB队列，该队列是 每个线程独有的，最终会汇总到全局的SATB队列 4.重新标记和处理跨代引用 ​ 处理并发标记的引用变化，扫描跨代引用，确保所有存活对象被标记 5.标记完成与垃圾回收 重新标记 重新标记阶段是为了修正在并发标记期间，因应用程序继续运作而导致标记产生变动的那一部分标记记录，空区域被删除和回收，计算所有区域的区域活跃度 清理 选择活跃度最低的区域，这些区域可以最快被收集，且同时和年轻代一起收集 清除后 清理阶段也会暂停用户线程，在最终标记阶段完成之后，G1垃圾回收器会整理Region区域，调整对应的记忆集，若识别到某个Region不存在任何存活对象时，会直接清理掉该Region，释放内存 链接 http://ulemony.github.io/posts/935a6b06.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://ulemony.github.io/tags/jvm/"}]},{"title":"JVM","slug":"JVM","date":"2025-01-20T02:19:31.000Z","updated":"2025-02-05T10:09:08.636Z","comments":true,"path":"posts/66c016fb.html","link":"","permalink":"http://ulemony.github.io/posts/66c016fb.html","excerpt":"Java 虚拟机运行时数据区 java虚拟机栈由栈帧组成，存储了局部变量表、操作数栈、动态链接、方法出口等信息 局部变量表包含：","text":"Java 虚拟机运行时数据区 java虚拟机栈由栈帧组成，存储了局部变量表、操作数栈、动态链接、方法出口等信息 局部变量表包含： 基本数据类型（byte 1字节、char 2字节、short 2字节、int 4字节、float 4字节、long 8字节、double 8字节、boolean） 对象引用类型，只保存对象的地址，不保存对象内容 这些数据类型的存储空间以局部变量槽（slot）表示 操作数栈用于存储字节码指令执行过程中所需的操作数，比如，栈会存储加法、减法、乘法等操作符的操作数，并返回计算结果。操作数栈是临时性的，方法执行完后栈中的数据也会被销毁。 堆存放对象实例，能被所有线程共享 物理上可以存于不连续的空间，逻辑上是连续的 年轻代主要用于存储新创建的对象。大部分对象在创建时都会首先进入年轻代。年轻代的垃圾回收非常频繁，称为Minor GC（轻度垃圾回收） 年轻代的内存进一步分为： Eden空间：新创建的对象通常会首先分配到Eden区。 From Survivor区和To Survivor区：这两个区域用于存活对象的转移。如果Eden区的对象在一次GC后依然存活，会被移动到这两个区域之一。存活的对象会在两者之间来回复制，直到它们足够“老”而转移到老年代。 -XX:MaxTenuringThreshold 设置垃圾最大年龄，SurvivorTo和SurvivorFrom复制交换的次数 默认为15 取值范围0-15 老年代用于存储长时间存活的对象。经过多次GC后，年轻代中的一些对象会被晋升到老年代。老年代的垃圾回收比较少，称为Major GC或Full GC。老年代通常包含的是一些长时间存在于程序中的对象，如常驻内存的对象或较大的数据结构。 方法区存储类信息、常量、静态变量、运行时常量池、编译后的代码缓存 注意：JDK8废弃永久代概念，改用元空间 运行时常量池 用于存放类的常量信息，例如字面量和符号引用 ​ 字面量（Literal）是指在源代码中直接写出来的常量值，通常是一个固定的数值、字符串或字符。字面量在编译时就会被确定下来，并 且在编译后会被存储到常量池中。 ​ 例子： 1234567public class LiteralExample &#123;public static void main(String[] args) &#123; // 字面量 int a = 5; // 数值字面量 String str = &quot;Hello&quot;; // 字符串字面量 &#125;&#125; 5 和 &quot;Hello&quot; 就是字面量。 整数字面量（比如5）是数值型字面量。 字符串字面量（比如”Hello”）是字符串常量。 ​ 这些字面量在编译期间就已经存在于类的常量池中了。 ​ ​ 符号引用 是指在类的字节码中，引用其他类、方法、字段等时所使用的符号名（例如类名、方法名、字段名等），而不是直接的内存 地址。这些符号引用是延迟解析的，即JVM在运行时会根据符号引用来定位对应的实际内存地址。 ​ 例子：类的符号引用 1234567891011public class SymbolicReferenceExample &#123; public static void main(String[] args) &#123; // 使用 String 类的符号引用 String str = &quot;Hello&quot;; // 使用 Class 类的符号引用 Class&lt;?&gt; clazz = String.class; // 获取 String 类的 Class 对象 System.out.println(clazz.getName()); &#125;&#125; ​ 解释 在上面的代码中，String.class 是一个符号引用。它代表的是 String 类的类类型（Class 对象）。在编译时，JVM 只是记录了 String.class，而没有直接知道它在内存中的位置。只有在运行时，JVM 会根据符号引用 String.class 来查找并加载 String 类。 在 clazz.getName() 调用时，JVM 会根据符号引用解析出 String.class 对应的类对象，并且返回类的名称 &quot;java.lang.String&quot;。 链接 http://ulemony.github.io/posts/66c016fb.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://ulemony.github.io/tags/jvm/"}]},{"title":"springboot+redis实现缓存","slug":"springboot-redis实现缓存","date":"2024-02-03T00:03:07.000Z","updated":"2025-01-20T04:28:35.318Z","comments":true,"path":"posts/af5af1e3.html","link":"","permalink":"http://ulemony.github.io/posts/af5af1e3.html","excerpt":"Springbooot整合redis实现缓存依赖引入12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring boot 集成redis所需common-pool2--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-pool2.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.15&lt;/version&gt; &lt;/dependency&gt; 配置文件12345678spring: redis: port: 6379 host: 127.0.0.1 password: 123456 cache: type: redis","text":"Springbooot整合redis实现缓存依赖引入12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring boot 集成redis所需common-pool2--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-pool2.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.15&lt;/version&gt; &lt;/dependency&gt; 配置文件12345678spring: redis: port: 6379 host: 127.0.0.1 password: 123456 cache: type: redis 配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143@Slf4j@Configuration@EnableCaching@ConditionalOnClass(RedisOperations.class)@EnableConfigurationProperties(RedisProperties.class)public class RedisConfig extends CachingConfigurerSupport &#123; /** *设置@Cacheable 序列化方式以及缓过期时间 * @return */ @Bean public RedisCacheConfiguration redisCacheConfiguration()&#123; FastJsonRedisSerializer&lt;Object&gt; fastJsonRedisSerializer=new FastJsonRedisSerializer&lt;&gt;(Object.class); RedisCacheConfiguration cacheConfiguration=RedisCacheConfiguration.defaultCacheConfig(); cacheConfiguration=cacheConfiguration.serializeValuesWith(RedisSerializationContext. SerializationPair.fromSerializer(fastJsonRedisSerializer)).entryTtl(Duration.ofHours(1)); return cacheConfiguration; &#125; @Bean(name = &quot;redisTemplate&quot;) @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;) public RedisTemplate&lt;Object,Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;Object,Object&gt; template=new RedisTemplate&lt;&gt;(); //序列化 FastJsonRedisSerializer&lt;Object&gt; fastJsonRedisSerializer= new FastJsonRedisSerializer&lt;&gt;(Object.class); //value值采用fastJsonRedisSerializer template.setValueSerializer(fastJsonRedisSerializer); template.setHashValueSerializer(fastJsonRedisSerializer); //指定序列化白名单 ParserConfig.getGlobalInstance().addAccept(&quot;com.example.springbootdemo.pojo&quot;); //key值采用StringSerializer template.setKeySerializer(new StringRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); template.setConnectionFactory(redisConnectionFactory); return template; &#125; /** *自定义缓存key生成策略 * @return */ @Bean(name = &quot;selfkeyGenerator&quot;) @Primary @Override public KeyGenerator keyGenerator() &#123; return (target,method,params) -&gt; &#123; StringBuilder builder=new StringBuilder(); builder.append(method.getName()); builder.append(&quot;_&quot;); for(Object obj: params)&#123; builder.append(JSON.toJSONString(obj).hashCode()); builder.append(&quot;_&quot;); &#125; String string=builder.toString(); // 做SHA256 Hash计算，得到一个SHA256摘要作为Key return DigestUtils.sha256(string); &#125;; &#125; @Bean @Override public CacheErrorHandler errorHandler() &#123; // 异常处理，当Redis发生异常时，打印日志，但是程序正常走 log.info(&quot;初始化 -&gt; [&#123;&#125;]&quot;, &quot;Redis CacheErrorHandler&quot;); return new CacheErrorHandler() &#123; @Override public void handleCacheGetError(RuntimeException e, Cache cache, Object key) &#123; log.error(&quot;Redis occur handleCacheGetError：key -&gt; [&#123;&#125;]&quot;, key, e); &#125; @Override public void handleCachePutError(RuntimeException e, Cache cache, Object key, Object value) &#123; log.error(&quot;Redis occur handleCachePutError：key -&gt; [&#123;&#125;]；value -&gt; [&#123;&#125;]&quot;, key, value, e); &#125; @Override public void handleCacheEvictError(RuntimeException e, Cache cache, Object key) &#123; log.error(&quot;Redis occur handleCacheEvictError：key -&gt; [&#123;&#125;]&quot;, key, e); &#125; @Override public void handleCacheClearError(RuntimeException e, Cache cache) &#123; log.error(&quot;Redis occur handleCacheClearError：&quot;, e); &#125; &#125;; &#125;&#125;class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; &#123; private Class&lt;T&gt; clazz; FastJsonRedisSerializer(Class&lt;T&gt; clazz)&#123; super(); this.clazz=clazz; &#125; @Override public byte[] serialize(T t) throws SerializationException &#123; if(t == null)&#123; return new byte[0]; &#125; return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(StandardCharsets.UTF_8); &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if(bytes == null || bytes.length == 0)&#123; return null; &#125; String str=new String(bytes,StandardCharsets.UTF_8); return JSON.parseObject(str,clazz); &#125;&#125;class StringRedisSerializer implements RedisSerializer&lt;Object&gt;&#123; private final Charset charset; StringRedisSerializer()&#123; this(StandardCharsets.UTF_8); &#125; private StringRedisSerializer(Charset charset)&#123; Assert.notNull(charset,&quot;Charset must not be null!&quot;); this.charset=charset; &#125; @Override public byte[] serialize(Object o) throws SerializationException &#123; String string=JSON.toJSONString(o); if(!StringUtils.hasLength(string))&#123; return null; &#125; //去掉字符串中的双引号 string=string.replace(&quot;\\&quot;&quot;,&quot; &quot;); return string.getBytes(charset); &#125; @Override public Object deserialize(byte[] bytes) throws SerializationException &#123; return (bytes == null ? null : new String(bytes,charset)); &#125;&#125; 使用12345678910// @Cacheable(value = &quot;user&quot;,key = &quot;&#x27;id:&#x27;+ #p0&quot;) @Cacheable(value = &quot;user&quot;,keyGenerator = &quot;selfkeyGenerator&quot;) @Override public User findUserById(Long id) &#123; User user=userMapper.selectById(id); if(user==null)&#123; throw new EntityNotFoundException(User.class,&quot;id&quot;,id.toString()); &#125; return user; &#125; 链接 http://ulemony.github.io/posts/af5af1e3.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"},{"name":"Redis","slug":"Java/Redis","permalink":"http://ulemony.github.io/categories/Java/Redis/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"http://ulemony.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"异常处理","slug":"异常处理","date":"2024-01-31T14:05:46.000Z","updated":"2025-01-20T04:28:35.320Z","comments":true,"path":"posts/28877bf.html","link":"","permalink":"http://ulemony.github.io/posts/28877bf.html","excerpt":"异常处理自定义异常123456789public class EntityExistedException extends RuntimeException&#123; public EntityExistedException(Class clazz, String field, String val)&#123; super(EntityExistedException.generateMessage(clazz.getSimpleName(),field,val)); &#125; private static String generateMessage(String entity, String field, String val) &#123; return StringUtils.capitalize(entity)+&quot; with &quot;+field+&quot; &quot;+val+&quot; existed &quot;; &#125;&#125; 异常工具类12345678910public class ThrowableUtil &#123; public static String getStacktrace(Throwable throwable)&#123; StringWriter sw=new StringWriter(); try(PrintWriter pw=new PrintWriter(sw))&#123; throwable.printStackTrace(pw); return sw.toString(); &#125; &#125;&#125;","text":"异常处理自定义异常123456789public class EntityExistedException extends RuntimeException&#123; public EntityExistedException(Class clazz, String field, String val)&#123; super(EntityExistedException.generateMessage(clazz.getSimpleName(),field,val)); &#125; private static String generateMessage(String entity, String field, String val) &#123; return StringUtils.capitalize(entity)+&quot; with &quot;+field+&quot; &quot;+val+&quot; existed &quot;; &#125;&#125; 异常工具类12345678910public class ThrowableUtil &#123; public static String getStacktrace(Throwable throwable)&#123; StringWriter sw=new StringWriter(); try(PrintWriter pw=new PrintWriter(sw))&#123; throwable.printStackTrace(pw); return sw.toString(); &#125; &#125;&#125; 异常处理器ApiError123456789101112131415161718192021@Datapublic class ApiError &#123; private Integer status=400; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) private LocalDateTime time; private String message; public ApiError()&#123; this.time=LocalDateTime.now(); &#125; public static ApiError error(String message)&#123; ApiError error=new ApiError(); error.setMessage(message); return error; &#125; public static ApiError error(Integer status,String message)&#123; ApiError error=new ApiError(); error.setStatus(status); error.setMessage(message); return error; &#125;&#125; handler1234567891011121314151617181920@Slf4j@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = EntityNotFoundException.class) public ResponseEntity&lt;ApiError&gt; entityNotFoundException(EntityNotFoundException e)&#123; log.error(ThrowableUtil.getStacktrace(e)); ApiError error=ApiError.error(NOT_FOUND.value(),e.getMessage()); return buildResponseEntity(error); &#125; @ExceptionHandler(value = EntityExistedException.class) public ResponseEntity&lt;ApiError&gt; entityExistedException(EntityExistedException e)&#123; log.error(ThrowableUtil.getStacktrace(e)); ApiError error=ApiError.error(e.getMessage()); return buildResponseEntity(error); &#125; private ResponseEntity&lt;ApiError&gt; buildResponseEntity(ApiError error) &#123; return new ResponseEntity&lt;&gt;(error,HttpStatus.valueOf(error.getStatus())); &#125;&#125; 具体使用1throw new EntityExistedException(User.class,&quot;username&quot;,user.getUsername()); 链接 http://ulemony.github.io/posts/28877bf.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"http://ulemony.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"mybatis plus分页","slug":"mybatis-plus分页","date":"2024-01-28T02:32:13.000Z","updated":"2025-01-20T04:28:35.321Z","comments":true,"path":"posts/4c979fe7.html","link":"","permalink":"http://ulemony.github.io/posts/4c979fe7.html","excerpt":"springboot使用mybatis plus分页引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 配置类123456789@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor=new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return interceptor; &#125;&#125;","text":"springboot使用mybatis plus分页引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 配置类123456789@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor=new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return interceptor; &#125;&#125; controller参数current：当前页面；size：每页大小 123456@ResponseBody@GetMapping(&quot;/list&quot;)public ResponseEntity&lt;PageUtils&lt;User&gt;&gt; queryUserByPage(@RequestParam(defaultValue = &quot;1&quot;) int current,@RequestParam(defaultValue = &quot;10&quot;) int size)&#123; IPage&lt;User&gt; page=userService.queryUserBypage(current,size); return new ResponseEntity&lt;&gt;( new PageUtils&lt;&gt;(page), HttpStatus.OK);&#125; service层实现12345678910@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123; @Autowired UserMapper userMapper; @Override public IPage&lt;User&gt; queryUserBypage(int current, int size) &#123; Page&lt;User&gt; page=new Page&lt;&gt;(current,size); return userMapper.queryUserByPage(page); &#125;&#125; mapper123public interface UserMapper extends BaseMapper&lt;User&gt; &#123; IPage&lt;User&gt; queryUserByPage(Page&lt;User&gt; page);&#125; xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.springbootdemo.mapper.UserMapper&quot;&gt; &lt;!-- public Account getAcct(Long id); --&gt;&lt;!-- 通用查询--&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.example.springbootdemo.pojo.User&quot;&gt; &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;phone&quot; property=&quot;phone&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;avatar_name&quot; property=&quot;avatarName&quot;/&gt; &lt;result column=&quot;avatar_path&quot; property=&quot;avatarPath&quot;/&gt; &lt;result column=&quot;is_admin&quot; property=&quot;isAdmin&quot;/&gt; &lt;result column=&quot;enabled&quot; property=&quot;enabled&quot;/&gt; &lt;result column=&quot;create_time&quot; property=&quot;createTime&quot;/&gt; &lt;result column=&quot;update_time&quot; property=&quot;updateTime&quot;/&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot;&gt; u.username as username,u.password as password, u.email as email, u.phone as phone,u.is_admin as is_admin, u.gender as gender, u.avatar_name as avatar_name, u.avatar_path as avatar_path, u.enabled as enabled, u.create_time as create_time, u.update_time as update_time &lt;/sql&gt;&lt;!-- 分页查询--&gt; &lt;select id=&quot;queryUserByPage&quot; resultMap=&quot;BaseResultMap&quot;&gt; select u.user_id as user_id, &lt;include refid=&quot;Base_Column_List&quot;&gt;&lt;/include&gt; from sys_user u &lt;/select&gt;&lt;/mapper&gt; 分页工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242public class PageUtils&lt;T&gt; &#123; //上一页 private int prev; //下一页 private int next; //首页 private int first = 1; //当前页码 private int currentPage; //尾页 private int last; //总页数 private int totalPage; //每页大小 private int pageSize; //数据 List&lt;T&gt; list = new ArrayList&lt;&gt;(); //开始序列号 private int startNum; //总条数 private int total; //显示总页码 private int count = 8; // 是否为第一页 private boolean isFirstPage = false; // 是否为最后一页 private boolean isLastPage = false; // 是否有前一页 private boolean hasPreviousPage = false; // 是否有下一页 private boolean hasNextPage = false; // 所有导航页号 private int[] navigatePageNumbers; public PageUtils(int pageSize, int currentPage, int total) &#123; this.pageSize = pageSize; this.currentPage = currentPage; this.total = total; this.totalPage=this.last= (int) Math.ceil((double) total/pageSize); this.prev=Math.max(this.currentPage-1,1); this.next=Math.min(this.currentPage+1,totalPage); this.startNum=(this.currentPage-1)*pageSize; //基本参数设定之后进行导航页面的计算 calcNavigatePageNumbers(); //以及页面边界的判定 judgePageBoudary(); &#125; private void calcNavigatePageNumbers() &#123; if(totalPage&lt;=count)&#123; navigatePageNumbers=new int[totalPage]; for(int i=0;i&lt;totalPage;i++)&#123; navigatePageNumbers[i]=i+1; &#125; &#125;else&#123; navigatePageNumbers=new int[count]; int start=currentPage-count/2; int end=currentPage+count/2; if(start&lt;1)&#123; start=1; //最前count页 for(int i=0;i&lt;count;i++)&#123; navigatePageNumbers[i]=start++; &#125; &#125;else if(end&gt;totalPage)&#123; //最后count页 end=totalPage; for(int i=count-1;i&gt;=0;i--)&#123; navigatePageNumbers[i]=end--; &#125; &#125;else&#123; //中间页 for(int i=0;i&lt;count;i++)&#123; navigatePageNumbers[i]=start++; &#125; &#125; &#125; &#125; public PageUtils(IPage&lt;T&gt; page)&#123; this.pageSize = (int) page.getSize(); this.currentPage = (int) page.getCurrent(); this.total = (int) page.getTotal(); this.totalPage=this.last= (int) page.getPages(); this.prev=Math.max((int) page.getCurrent()-1,1); this.next=Math.min((int) page.getCurrent()+1,(int) page.getPages()); this.startNum=((int) page.getCurrent()-1)*(int) page.getSize(); this.list=page.getRecords(); //基本参数设定之后进行导航页面的计算 calcNavigatePageNumbers(); //以及页面边界的判定 judgePageBoudary(); &#125; private void judgePageBoudary() &#123; this.isFirstPage= currentPage == 1; this.isLastPage= currentPage == totalPage &amp;&amp; currentPage != 1; this.hasPreviousPage= currentPage != 1; this.hasNextPage= currentPage != totalPage; &#125; public int getPrev() &#123; return prev; &#125; public void setPrev(int prev) &#123; this.prev = prev; &#125; public int getNext() &#123; return next; &#125; public void setNext(int next) &#123; this.next = next; &#125; public int getCurrentPage() &#123; return currentPage; &#125; public void setCurrentPage(int currentPage) &#123; this.currentPage = currentPage; &#125; public int getLast() &#123; return last; &#125; public void setLast(int last) &#123; this.last = last; &#125; public int getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public List&lt;T&gt; getList() &#123; return list; &#125; public void setList(List&lt;T&gt; list) &#123; this.list = list; &#125; public int getStartNum() &#123; return startNum; &#125; public void setStartNum(int startNum) &#123; this.startNum = startNum; &#125; public int getTotal() &#123; return total; &#125; public void setTotal(int total) &#123; this.total = total; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public int getFirst() &#123; return first; &#125; public void setFirst(int first) &#123; this.first = first; &#125; public void setFirstPage(boolean firstPage) &#123; isFirstPage = firstPage; &#125; public boolean isFirstPage() &#123; return isFirstPage; &#125; public boolean isLastPage() &#123; return isLastPage; &#125; public void setLastPage(boolean lastPage) &#123; isLastPage = lastPage; &#125; public boolean isHasPreviousPage() &#123; return hasPreviousPage; &#125; public void setHasPreviousPage(boolean hasPreviousPage) &#123; this.hasPreviousPage = hasPreviousPage; &#125; public boolean isHasNextPage() &#123; return hasNextPage; &#125; public void setHasNextPage(boolean hasNextPage) &#123; this.hasNextPage = hasNextPage; &#125; public int[] getNavigatePageNumbers() &#123; return navigatePageNumbers; &#125; @Override public String toString() &#123; return JSONUtil.toJsonStr(this); &#125; 前端html页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!doctype html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;!-- 必须的 meta 标签 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;用户展示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table class=&quot;table table-hover table-bordered table-striped text-center&quot; style=&quot;width: 70%;margin: auto;margin-top: 30px&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th class=&quot;text-center&quot;&gt;id&lt;/th&gt; &lt;th class=&quot;text-center&quot;&gt;姓名&lt;/th&gt; &lt;th class=&quot;text-center&quot;&gt;邮箱&lt;/th&gt; &lt;th class=&quot;text-center&quot;&gt;手机&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=&quot;user:$&#123;pageUtils.list&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.username&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.phone&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;!--显示分页信息部分代码--&gt;&lt;div class=&quot;text-center&quot;&gt; &lt;div class=&quot;btn-group mr-2&quot;&gt; &lt;ul class=&quot;pagination pull-right no-margin&quot;&gt; &lt;li class=&quot; bg-light text-dark&quot; th:if=&quot;$&#123;pageUtils.hasPreviousPage&#125;&quot;&gt; &lt;a th:href=&quot;&#x27;/listUser?current=1&amp;size=&#x27;+$&#123;pageUtils.pageSize&#125;&quot;&gt;首页&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;prev bg-light text-dark&quot; th:if=&quot;$&#123;pageUtils.hasPreviousPage&#125;&quot;&gt; &lt;a th:href=&quot;&#x27;/listUser?current=&#x27;+$&#123;pageUtils.prev&#125;+&#x27;&amp;size=&#x27;+$&#123;pageUtils.pageSize&#125;&quot;&gt; &lt;&lt; &lt;/a&gt; &lt;/li&gt; &lt;li th:each=&quot;nav : $&#123;pageUtils.navigatePageNumbers&#125;&quot; class=&quot; bg-light text-dark&quot; &gt; &lt;a th:href=&quot;&#x27;/listUser?current=&#x27;+$&#123;nav&#125;+&#x27;&amp;size=&#x27;+$&#123;pageUtils.pageSize&#125;&quot; th:if=&quot;$&#123;nav != pageUtils.currentPage&#125;&quot; th:text=&quot;$&#123;nav&#125;&quot;&gt;&lt;/a&gt; &lt;span style=&quot;font-weight: bold;&quot; th:if=&quot;$&#123;nav == pageUtils.currentPage&#125;&quot; th:text=&quot;$&#123;nav&#125;&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;next bg-light text-dark&quot; th:if=&quot;$&#123;pageUtils.hasNextPage&#125;&quot;&gt; &lt;a th:href=&quot;&#x27;/listUser?current=&#x27;+$&#123;pageUtils.next&#125;+&#x27;&amp;size=&#x27;+$&#123;pageUtils.pageSize&#125;&quot;&gt; &gt;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;bg-light text-dark&quot;&gt; &lt;a th:href=&quot;&#x27;/listUser?current=&#x27;+$&#123;pageUtils.last&#125;+&#x27;&amp;size=&#x27;+$&#123;pageUtils.pageSize&#125;&quot;&gt;尾页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;text-center&quot;&gt; &lt;span&gt;当前页数: &lt;strong&gt;[[$&#123;pageUtils.currentPage&#125;]]&lt;/strong&gt; 页&lt;/span&gt;&amp;nbsp;&amp;nbsp; &lt;span&gt;总页数: &lt;strong&gt;[[$&#123;pageUtils.totalPage&#125;]]&lt;/strong&gt; 页&lt;/span&gt;&amp;nbsp;&amp;nbsp; &lt;span&gt;总数据: &lt;strong&gt;[[$&#123;pageUtils.total&#125;]]&lt;/strong&gt; 条&lt;/span&gt;&lt;/div&gt;&lt;!-- 如果要使用Bootstrap的js插件 必须要先调入jQUery --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;&lt;!-- bootstrap的js 插件 --&gt;&lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 链接 http://ulemony.github.io/posts/4c979fe7.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://ulemony.github.io/tags/mybatis/"},{"name":"分页","slug":"分页","permalink":"http://ulemony.github.io/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"Java开发小技巧","slug":"Java开发小技巧","date":"2024-01-25T09:38:46.000Z","updated":"2025-01-20T04:28:35.317Z","comments":true,"path":"posts/736315d6.html","link":"","permalink":"http://ulemony.github.io/posts/736315d6.html","excerpt":"数据库插入自动创建时间在createTime字段上添加@TableField(fill = FieldFill.INSERT)注解插入数据时自动填充数据， 使用@DateTimeFormat注解来指定日期的格式如yy-MM-dd hh:mm:ss 12345678910111213141516171819import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableName;import org.springframework.format.annotation.DateTimeFormat;import java.util.Date;@TableName(&quot;your_table_name&quot;)public class YourEntity &#123; // 其他字段... @TableField(fill = FieldFill.INSERT) @DateTimeFormat(pattern = &quot;yy-MM-dd HH:mm:ss&quot;) private Date createTime; // 构造方法、Getter和Setter方法...&#125; 对于指定日期格式还可以使用Timestamp类型","text":"数据库插入自动创建时间在createTime字段上添加@TableField(fill = FieldFill.INSERT)注解插入数据时自动填充数据， 使用@DateTimeFormat注解来指定日期的格式如yy-MM-dd hh:mm:ss 12345678910111213141516171819import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableName;import org.springframework.format.annotation.DateTimeFormat;import java.util.Date;@TableName(&quot;your_table_name&quot;)public class YourEntity &#123; // 其他字段... @TableField(fill = FieldFill.INSERT) @DateTimeFormat(pattern = &quot;yy-MM-dd HH:mm:ss&quot;) private Date createTime; // 构造方法、Getter和Setter方法...&#125; 对于指定日期格式还可以使用Timestamp类型 1234567891011121314151617import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableName;import java.sql.Timestamp;@TableName(&quot;your_table_name&quot;)public class YourEntity &#123; // 其他字段... @TableField(fill = FieldFill.INSERT) private Timestamp createTime; // 构造方法、Getter和Setter方法...&#125; 创建处理器类 123456789101112131415@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; /* 创建时间 */ this.strictInsertFill(metaObject, &quot;createTime&quot;, Timestamp.class, DateTime.now().toTimestamp()); this.strictInsertFill(metaObject, &quot;updateTime&quot;, Timestamp.class, DateTime.now().toTimestamp()); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.strictUpdateFill(metaObject,&quot;updateTime&quot;,Timestamp.class, DateTime.now().toTimestamp()); &#125;&#125; 链接 http://ulemony.github.io/posts/736315d6.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://ulemony.github.io/tags/mysql/"},{"name":"mybatis plus","slug":"mybatis-plus","permalink":"http://ulemony.github.io/tags/mybatis-plus/"}]},{"title":"chatgpt聊天机器人部署","slug":"chatgpt聊天机器人部署","date":"2024-01-23T14:27:18.000Z","updated":"2024-01-23T16:39:38.048Z","comments":true,"path":"posts/9fa1f056.html","link":"","permalink":"http://ulemony.github.io/posts/9fa1f056.html","excerpt":"window环境下的部署后端项目部署1.环境准备1.1 jdk1.8安装安装教程","text":"window环境下的部署后端项目部署1.环境准备1.1 jdk1.8安装安装教程 1https://blog.csdn.net/m0_70098804/article/details/131062308?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169028921016800225560646%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169028921016800225560646&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-1-131062308-null-null.142^v91^insertT0,239^v3^control&amp;utm_term=jdk1.8%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80&amp;spm=1018.2226.3001.4187 安装包下载地址 1https://www.oracle.com/cn/java/technologies/downloads/#java8-windows 1.2 maven3.9.3安装安装教程 1https://blog.csdn.net/weixin_44080187/article/details/122933194?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169029399616800226565364%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169029399616800226565364&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-122933194-null-null.142^v91^insertT0,239^v3^control&amp;utm_term=window%E5%AE%89%E8%A3%85maven&amp;spm=1018.2226.3001.4187 安装包下载地址 1https://maven.apache.org/download.cgi 1.3 微软语音服务获取a. Azure 订阅 - 免费创建订阅 b. 在 Azure 门户中创建语音资源 c. 获取语音资源密钥和区域。 部署语音资源后，选择“转到资源”以查看和管理密钥。 2.后端项目启动2.1 配置文件application.yaml修改修改工具：软件idea或者HBuilderX a.将openai的apiKey替换会你自己的apiKey 12openai: apiKey: xxxx b.将步骤1.3得到的语音密钥和区域设置成自己的密钥和区域 12345azure:#语音服务密钥 SPEECH_KEY: xxxx#语音服务地区 SERVICE_REGION: eastus c.在配置文件application.yaml中替换代理端口和地址 1234#代理地址和端口proxy: host: localhost port: 7890 2.2 修改语音文件保存路径a. 修改AudioUtil.java 文件 在本地电脑自定义新建文件夹 1234文件夹1C:\\audio\\input文件夹2C:\\audio\\output 将下图的两个语音路径替换成上面自定义的路径，注意路径需使用符号&#x2F; 即： 12345678// 构造原始音频文件保存目录 保存至电脑本地 String inputFilePath = &quot;/Users/lee/Desktop/audio/input&quot;; 修改为 String inputFilePath = &quot;C:/audio/input&quot;;//构建格式化后音频文件保存目录 String outputFilePath = &quot;/Users/lee/Desktop/audio/output&quot;; 修改为 String outputFilePath = &quot;C:/audio/output&quot;; b.修改TextToSpeechImpl.java文件 将下图的路径替换成自定义路径 1234//生成语音文件保存到本地 String outputFilePath=&quot;/Users/lee/Desktop/audio/output&quot;; 修改为 String outputFilePath=&quot;C:/audio/output&quot;; 2.3启动后端项目a.在命令窗口中cd进入项目根目录 1cd C:\\chatgpt-master-master b. 输入命令打包项目,初次打包会耗时较长时间 1mvn package c. 成功打包项目后会在项目中看到一个target目录，cd进入该目录 1cd C:\\chatgpt-master-master\\target d. 运行项目 电脑需要开启全局代理 1java -Xms64m -Xmx128m -jar miniLegionInit.jar 前端项目部署1.环境准备1.1 node环境安装具体安装教程 1https://blog.csdn.net/mengchuan6666/article/details/125893199?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=window%E5%AE%89%E8%A3%85vue4.5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-125893199.142^v91^insertT0,239^v3^control&amp;spm=1018.2226.3001.4187 node.js安装包下载地址 1https://nodejs.org/dist/v14.17.0/ 我安装的版本是 node-v14.17.0-x64.msi 安装成功后查看版本号 1npm -v 1.2 NPM安装vue.js1npm install vue -g 1.3 全局安装vue-cli1npm install -g @vue/cli 2.前端项目启动2.1 修改ChatBox.vue文件将ip地址192.168.100.204替换成自己电脑的ip地址 2.2 启动前端项目a. 以管理员身份运行命令窗口，cd进入项目根目录 1cd C:\\chatgpt_vue-master b. 启动项目，注意先启动后端项目再启动前端项目 1npm run serve c. 启动成功后可以看到以下代码 1234DONE Compiled successfully in 15920ms 上午8:54:02 App running at: - Local: http://localhost:8081/ - Network: http://192.168.8.209:8081/ d.浏览器访问地址即可打开网页 1http://localhost:8081/ 链接 http://ulemony.github.io/posts/9fa1f056.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"chatgpt","slug":"chatgpt","permalink":"http://ulemony.github.io/tags/chatgpt/"}]},{"title":"SpringBoot自动配置原理","slug":"SpringBoot自动配置原理","date":"2024-01-23T14:24:06.000Z","updated":"2024-01-23T16:39:32.250Z","comments":true,"path":"posts/ec6e45b4.html","link":"","permalink":"http://ulemony.github.io/posts/ec6e45b4.html","excerpt":"Springboot自动配置原理 SpringBoot通过@EnableAutoConfiguration开启自动配置 利用@Import加载META-INF&#x2F;spring.factories配置文件中的所有自动配置类 这些配置类会根据@Conditionnal派生注解来生效 这些自动配置类会通过以Properties结尾命名的类获取全局配置文件中的属性 xxxProperties类通过@ConfigurationProperties注解和全局配置文件中的属性进行绑定 源码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration//通过该注解开启自动配置@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @AliasFor(annotation = EnableAutoConfiguration.class) Class&lt;?&gt;[] exclude() default &#123;&#125;; @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default &#123;&#125;; @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;) String[] scanBasePackages() default &#123;&#125;; @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage//注入类@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class&lt;?&gt;[] exclude() default &#123;&#125;; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default &#123;&#125;;&#125;AutoConfigurationImportSelector.class @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader //加载自动配置类 .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125;AutoConfigurationMetadataLoader.class public static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) &#123; return loadMetadata(classLoader, PATH); &#125; static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) &#123; try &#123; //实际上从&quot;META-INF/&quot; + &quot;spring-autoconfigure-metadata.properties&quot;下加载自动配置类 Enumeration&lt;URL&gt; urls = (classLoader != null) ? classLoader.getResources(path) : ClassLoader.getSystemResources(path); Properties properties = new Properties(); while (urls.hasMoreElements()) &#123; properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource(urls.nextElement()))); &#125; return loadMetadata(properties); &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(&quot;Unable to load @ConditionalOnClass location [&quot; + path + &quot;]&quot;, ex); &#125; &#125;@Configuration @Conditional(DefaultDispatcherServletCondition.class) @ConditionalOnClass(ServletRegistration.class)//从xxxProperties类中获取全局配置文件属性值 @EnableConfigurationProperties(&#123; HttpProperties.class, WebMvcProperties.class &#125;) protected static class DispatcherServletConfiguration //通过该注解和全局配置文件中的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;)public class HttpProperties 链接 http://ulemony.github.io/posts/ec6e45b4.html","text":"Springboot自动配置原理 SpringBoot通过@EnableAutoConfiguration开启自动配置 利用@Import加载META-INF&#x2F;spring.factories配置文件中的所有自动配置类 这些配置类会根据@Conditionnal派生注解来生效 这些自动配置类会通过以Properties结尾命名的类获取全局配置文件中的属性 xxxProperties类通过@ConfigurationProperties注解和全局配置文件中的属性进行绑定 源码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration//通过该注解开启自动配置@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @AliasFor(annotation = EnableAutoConfiguration.class) Class&lt;?&gt;[] exclude() default &#123;&#125;; @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default &#123;&#125;; @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;) String[] scanBasePackages() default &#123;&#125;; @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage//注入类@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class&lt;?&gt;[] exclude() default &#123;&#125;; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default &#123;&#125;;&#125;AutoConfigurationImportSelector.class @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader //加载自动配置类 .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125;AutoConfigurationMetadataLoader.class public static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) &#123; return loadMetadata(classLoader, PATH); &#125; static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) &#123; try &#123; //实际上从&quot;META-INF/&quot; + &quot;spring-autoconfigure-metadata.properties&quot;下加载自动配置类 Enumeration&lt;URL&gt; urls = (classLoader != null) ? classLoader.getResources(path) : ClassLoader.getSystemResources(path); Properties properties = new Properties(); while (urls.hasMoreElements()) &#123; properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource(urls.nextElement()))); &#125; return loadMetadata(properties); &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(&quot;Unable to load @ConditionalOnClass location [&quot; + path + &quot;]&quot;, ex); &#125; &#125;@Configuration @Conditional(DefaultDispatcherServletCondition.class) @ConditionalOnClass(ServletRegistration.class)//从xxxProperties类中获取全局配置文件属性值 @EnableConfigurationProperties(&#123; HttpProperties.class, WebMvcProperties.class &#125;) protected static class DispatcherServletConfiguration //通过该注解和全局配置文件中的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;)public class HttpProperties 链接 http://ulemony.github.io/posts/ec6e45b4.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://ulemony.github.io/tags/springboot/"}]},{"title":"Spring事务","slug":"Spring事务","date":"2024-01-23T14:22:14.000Z","updated":"2024-01-23T16:39:25.921Z","comments":true,"path":"posts/65703737.html","link":"","permalink":"http://ulemony.github.io/posts/65703737.html","excerpt":"Spring事务是如何实现的 Spring事务底层基于数据库事务和AOP机制 对使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean 调用代理对象的方法时，会先判断该方法是否有@Transactional注解，如果加了会利用事务管理器创建一个数据库连接，并且将数据库连接的autocommit属性设置为false，禁止连接自动提交 执行当前方法，方法中会执行sql，方法执行完后如果没有异常就提交事务；如果出现了异常则回滚事务，至于哪些异常回滚事务，可以通过@Transactional注解的rollbackFor进行配置，默认会对RuntimeException和erroe进行回滚 Spring事务隔离级别spring事务隔离级别就是数据库的隔离级别，它是基于数据库连接来做的，一个事务对应一个数据库连接，如果传播机制要新开事务，实际上是新建一个数据库连接来执行sql 1.read uncommitted 未提交读","text":"Spring事务是如何实现的 Spring事务底层基于数据库事务和AOP机制 对使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean 调用代理对象的方法时，会先判断该方法是否有@Transactional注解，如果加了会利用事务管理器创建一个数据库连接，并且将数据库连接的autocommit属性设置为false，禁止连接自动提交 执行当前方法，方法中会执行sql，方法执行完后如果没有异常就提交事务；如果出现了异常则回滚事务，至于哪些异常回滚事务，可以通过@Transactional注解的rollbackFor进行配置，默认会对RuntimeException和erroe进行回滚 Spring事务隔离级别spring事务隔离级别就是数据库的隔离级别，它是基于数据库连接来做的，一个事务对应一个数据库连接，如果传播机制要新开事务，实际上是新建一个数据库连接来执行sql 1.read uncommitted 未提交读 2.read committed 提交读、不可重复读 3.repeatable read 可重复读 4.serializable 可串行化 Spring事务传播机制 REQUIRED：如果当前没有事务则新建一个事务，如果有就加入该事务 SUPPORTS：当前存在事务则加入该事务，没有则以非事务方法执行 MANDATORY：当前存在事务则加入该事务，没有则抛出异常 REQUIRED_NEW：创建一个新事务，如果当前存在事务则将其挂起 NOT_SUPPORTED：以非事务方式执行，如果当前存在事务则将其挂起 NEVER：不使用事务，如果当前存在事务则抛出异常 NESTED：如果当前事务存在，则在嵌套事务中执行，如果不存在事务则新建一个事务 事务失效 方法内自调用：Spring事务是基于AOP的，只有使用代理对象调用某个方法时，事务才生效，如果一个方法中使用this.xxx（）调用方法时，this不是代理对象，导致事务失效 a. 解决办法1: 把调用方法拆分到另外一个bean b. 解决办法2: 自己注入自己 c. 解决办法3: AopContext.currentProxy()+@EnableAspectJAutoProxy(exposeProxy&#x3D;true) 方法是private的：Spring事务基于CGLIB来进行AOP，而CGLIB基于父子类生效，子类是代理类，父类是被代理类，如果父类某个方法是private，子类没办法重写，也就不能增加spring事务的逻辑 方法是final的：原因同上 单独的线程：当Mybatis或JdbcTemplate执行sql时，会从ThreadLocal中获取数据库连接对象，如果开启事务的线程和执行sql的线程不是同一个线程，那么Mybatis或JdbcTemplate就会新建一个数据库连接来执行sql，此时autocommit为true，执行完sql便提交，后续即使抛出异常也不会进行回滚 spring事务没有捕捉到异常，从而不回滚 类没有被Spring管理 数据库不支持事务 链接 http://ulemony.github.io/posts/65703737.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://ulemony.github.io/tags/spring/"}]},{"title":"Spring之Bean的生命周期","slug":"Spring之Bean的生命周期","date":"2024-01-23T14:19:58.000Z","updated":"2024-01-23T16:39:20.898Z","comments":true,"path":"posts/c7e03167.html","link":"","permalink":"http://ulemony.github.io/posts/c7e03167.html","excerpt":"Bean的生命周期1.实例化实例化前实例化前,会执行InstantiationAwareBeanPostProcessor这种后置处理器的postProcessBeforeInstantiation方法，可以用于动态地创建或替换 bean 实例，从而实现更高级的定制和控制。 实例化前的部分源码","text":"Bean的生命周期1.实例化实例化前实例化前,会执行InstantiationAwareBeanPostProcessor这种后置处理器的postProcessBeforeInstantiation方法，可以用于动态地创建或替换 bean 实例，从而实现更高级的定制和控制。 实例化前的部分源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384AbstractAutowireCapableBeanFactory.class protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; RootBeanDefinition mbdToUse = mbd; Class&lt;?&gt; resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException var9) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, var9); &#125; Object beanInstance; try &#123; //实例化前 beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse); if (beanInstance != null) &#123; return beanInstance; &#125; &#125; catch (Throwable var10) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, var10); &#125; try &#123; //创建对象 beanInstance = this.doCreateBean(beanName, mbdToUse, args); if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; return beanInstance; &#125; catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123; throw var7; &#125; catch (Throwable var8) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, var8); &#125; &#125; @Nullable protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123; Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123; if (!mbd.isSynthetic() &amp;&amp; this.hasInstantiationAwareBeanPostProcessors()) &#123; Class&lt;?&gt; targetType = this.determineTargetType(beanName, mbd); if (targetType != null) &#123; bean = this.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) &#123; bean = this.applyBeanPostProcessorsAfterInitialization(bean, beanName); &#125; &#125; &#125; mbd.beforeInstantiationResolved = bean != null; &#125; return bean; &#125; @Nullable protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; Iterator var3 = this.getBeanPostProcessors().iterator(); while(var3.hasNext()) &#123; BeanPostProcessor bp = (BeanPostProcessor)var3.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; //会执行InstantiationAwareBeanPostProcessor这种后置处理器的postProcessBeforeInstantiation方法 Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) &#123; return result; &#125; &#125; &#125; return null; &#125; 实例化时的部分源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889AbstractAutowireCapableBeanFactory.class protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; //创建bean实例，推断构造方法 instanceWrapper = this.createBeanInstance(beanName, mbd, args); &#125; //创建bean Object bean = instanceWrapper.getWrappedInstance(); Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) &#123; mbd.resolvedTargetType = beanType; &#125; synchronized(mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable var17) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, var17); &#125; mbd.postProcessed = true; &#125; &#125; boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName); if (earlySingletonExposure) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName + &quot;&#x27; to allow for resolving potential circular references&quot;); &#125; this.addSingletonFactory(beanName, () -&gt; &#123; return this.getEarlyBeanReference(beanName, mbd, bean); &#125;); &#125; Object exposedObject = bean; try &#123; //属性填充 this.populateBean(beanName, mbd, instanceWrapper); //初始化bean exposedObject = this.initializeBean(beanName, exposedObject, mbd); &#125; catch (Throwable var18) &#123; if (var18 instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) &#123; throw (BeanCreationException)var18; &#125; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, var18); &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = this.getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) &#123; String[] dependentBeans = this.getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length); String[] var12 = dependentBeans; int var13 = dependentBeans.length; for(int var14 = 0; var14 &lt; var13; ++var14) &#123; String dependentBean = var12[var14]; if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;); &#125; &#125; &#125; &#125; try &#123; this.registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject; &#125; catch (BeanDefinitionValidationException var16) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, var16); &#125; &#125; 2.属性赋值在赋值的过程中会执行InstantiationAwareBeanPostProcessor这种后置处理器的postProcessAfterInstantiation方法，进行一些额外的控制或自定义操作。如果返回 false，则表示中断属性注入过程。 实现InstantiationAwareBeanPostProcessor接口重写postProcessProperties方法，在bean实例化后，属性注入前，可以根据属性描述，动态的新增，删除，修改一些属性。 属性填充源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788AbstractAutowireCapableBeanFactory.class protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123; if (bw == null) &#123; if (mbd.hasPropertyValues()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); &#125; &#125; else &#123; boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; this.hasInstantiationAwareBeanPostProcessors()) &#123; Iterator var5 = this.getBeanPostProcessors().iterator(); while(var5.hasNext()) &#123; BeanPostProcessor bp = (BeanPostProcessor)var5.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; //如果后置处理器存在且其中任何一个的 postProcessAfterInstantiation 方法返回 false，则中断属性注入过程。 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (continueWithPropertyPopulation) &#123; PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : null; if (mbd.getResolvedAutowireMode() == 1 || mbd.getResolvedAutowireMode() == 2) &#123; MutablePropertyValues newPvs = new MutablePropertyValues((PropertyValues)pvs); if (mbd.getResolvedAutowireMode() == 1) &#123; this.autowireByName(beanName, mbd, bw, newPvs); &#125; if (mbd.getResolvedAutowireMode() == 2) &#123; this.autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; boolean hasInstAwareBpps = this.hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = mbd.getDependencyCheck() != 0; PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) &#123; if (pvs == null) &#123; pvs = mbd.getPropertyValues(); &#125; Iterator var9 = this.getBeanPostProcessors().iterator(); while(var9.hasNext()) &#123; BeanPostProcessor bp = (BeanPostProcessor)var9.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; if (filteredPds == null) &#123; filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; //执行postProcessProperties方法 pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; return; &#125; &#125; pvs = pvsToUse; &#125; &#125; &#125; if (needsDepCheck) &#123; if (filteredPds == null) &#123; filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; this.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs); &#125; if (pvs != null) &#123; //属性最终填充 this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs); &#125; &#125; &#125; &#125; 3.初始化初始化前初始化前会处理Aware回调，执行invokeAwareMethods(beanName, bean)方法，使用 Aware 回调接口获取容器的名称、类加载器和工厂信息，以便在 bean 内部执行定制的逻辑。 然后执行BeanPostProcessor的postProcessBeforeInitialization方法，这允许开发人员在 bean 初始化前介入 bean 的创建过程，执行一些自定义逻辑，例如初始化前的数据校验。这是 Spring 容器提供的一个非常有用的扩展点，用于实现各种定制和增强功能。 初始化时实现InitializingBean的afterPropertiesSet()方法 执行自定义的初始化方法 初始化后执行BeanPostProcessor的postProcessAfterInitialization方法，可以进行AOP等操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113AbstractAutowireCapableBeanFactory.classprotected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(() -&gt; &#123; this.invokeAwareMethods(beanName, bean); return null; &#125;, this.getAccessControlContext()); &#125; else &#123; this.invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //执行BeanPostProcessor的postProcessBeforeInitialization方法 wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName); &#125; try &#123; this.invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable var6) &#123; throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, &quot;Invocation of init method failed&quot;, var6); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; private void invokeAwareMethods(String beanName, Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware)bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ClassLoader bcl = this.getBeanClassLoader(); if (bcl != null) &#123; ((BeanClassLoaderAware)bean).setBeanClassLoader(bcl); &#125; &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware)bean).setBeanFactory(this); &#125; &#125; &#125; protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd) throws Throwable &#123; boolean isInitializingBean = bean instanceof InitializingBean; if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; if (System.getSecurityManager() != null) &#123; try &#123; AccessController.doPrivileged(() -&gt; &#123; ((InitializingBean)bean).afterPropertiesSet(); return null; &#125;, this.getAccessControlContext()); &#125; catch (PrivilegedActionException var6) &#123; throw var6.getException(); &#125; &#125; else &#123; //执行InitializingBean的afterPropertiesSet()方法 ((InitializingBean)bean).afterPropertiesSet(); &#125; &#125; if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) &#123; String initMethodName = mbd.getInitMethodName(); if (StringUtils.hasLength(initMethodName) &amp;&amp; (!isInitializingBean || !&quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; //执行自定义的方法 this.invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125; &#125;AbstractAutowireCapableBeanFactory.class public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; Object current; for(Iterator var4 = this.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) &#123; BeanPostProcessor processor = (BeanPostProcessor)var4.next(); current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) &#123; return result; &#125; &#125; return result; &#125; public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; Object current; for(Iterator var4 = this.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) &#123; BeanPostProcessor processor = (BeanPostProcessor)var4.next(); current = processor.postProcessAfterInitialization(result, beanName); if (current == null) &#123; return result; &#125; &#125; return result; &#125; 4.销毁将所有容器中的单例bean相关信息移除，回调所有相关的后置处理器和bean的销毁方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void destroy() &#123; if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123; Iterator var1 = this.beanPostProcessors.iterator(); while(var1.hasNext()) &#123; DestructionAwareBeanPostProcessor processor = (DestructionAwareBeanPostProcessor)var1.next(); processor.postProcessBeforeDestruction(this.bean, this.beanName); &#125; &#125; if (this.invokeDisposableBean) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Invoking destroy() on bean with name &#x27;&quot; + this.beanName + &quot;&#x27;&quot;); &#125; try &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(() -&gt; &#123; ((DisposableBean)this.bean).destroy(); return null; &#125;, this.acc); &#125; else &#123; //实现DisposableBean接口的destoy()方法 ((DisposableBean)this.bean).destroy(); &#125; &#125; catch (Throwable var3) &#123; String msg = &quot;Invocation of destroy method failed on bean with name &#x27;&quot; + this.beanName + &quot;&#x27;&quot;; if (logger.isDebugEnabled()) &#123; logger.info(msg, var3); &#125; else &#123; logger.info(msg + &quot;: &quot; + var3); &#125; &#125; &#125; if (this.destroyMethod != null) &#123; this.invokeCustomDestroyMethod(this.destroyMethod); &#125; else if (this.destroyMethodName != null) &#123; Method methodToCall = this.determineDestroyMethod(this.destroyMethodName); if (methodToCall != null) &#123; //自定义的销毁方法 this.invokeCustomDestroyMethod(methodToCall); &#125; &#125; &#125; 链接 http://ulemony.github.io/posts/c7e03167.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://ulemony.github.io/tags/spring/"}]},{"title":"Spring循环依赖","slug":"Spring循环依赖","date":"2024-01-23T14:17:21.000Z","updated":"2024-01-23T16:39:16.179Z","comments":true,"path":"posts/a5d86a59.html","link":"","permalink":"http://ulemony.github.io/posts/a5d86a59.html","excerpt":"spring循环依赖AService里面有BService属性，BService里面有AService属性 12345678910111213141516171819202122232425260.creatingSet(&#x27;AService&#x27;)1.new Aservice() ---&gt; Aservice普通对象 ---&gt; 三级缓存singletonFactories&lt;aService,lambda(beanName,Aservice)&gt;2.填充bService属性 ---&gt;单例池Map ---&gt;找不到 创建BService 2.1 new BService() ---&gt; BService普通对象 2.2 添加aService属性 ---&gt; 单例池Map ---&gt;找不到 ---&gt; creatingSet ---&gt; AService循环依赖 ---&gt; 二级缓存---&gt; 三级缓存 ---&gt; lambda---&gt; 判断要不要AOP？---&gt; 提前进行AOP ---&gt; AService代理对象 ---&gt; 放入二级缓存,并且移除三级缓存的对象(不再需要lambda表达式) --------------&gt;AService普通对象 2.3 添加其他属性 2.4 其他步骤 2.5 放入单例池Map&lt;beanName, AService Bean对象&gt; 3.填充cService属性 创建CService 3.1 new CService() ---&gt; BService普通对象 3.2 添加aService属性 ---&gt; 单例池Map ---&gt;找不到 ---&gt; creatingSet ---&gt; AService循环依赖 ---&gt;第二级 3.3 添加其他属性 3.4 其他步骤 3.5 放入单例池Map&lt;beanName, AService Bean对象&gt; 4.其他步骤(AOP) ---&gt;AService 代理对象(?) ---&gt;判断是否提前进行了AOP若是则返回普通对象，否则进行AOP返回代理对象5.把二级缓存对象放入一级缓存单例池Map&lt;beanName, AService Bean对象&gt;，并移除二级缓存对象注意：普通对象没有值是一个半成品；Bean对象有值，是一个完整体 三级缓存第一级缓存：singletonObjects 单例池 保证bean对象的单例效果","text":"spring循环依赖AService里面有BService属性，BService里面有AService属性 12345678910111213141516171819202122232425260.creatingSet(&#x27;AService&#x27;)1.new Aservice() ---&gt; Aservice普通对象 ---&gt; 三级缓存singletonFactories&lt;aService,lambda(beanName,Aservice)&gt;2.填充bService属性 ---&gt;单例池Map ---&gt;找不到 创建BService 2.1 new BService() ---&gt; BService普通对象 2.2 添加aService属性 ---&gt; 单例池Map ---&gt;找不到 ---&gt; creatingSet ---&gt; AService循环依赖 ---&gt; 二级缓存---&gt; 三级缓存 ---&gt; lambda---&gt; 判断要不要AOP？---&gt; 提前进行AOP ---&gt; AService代理对象 ---&gt; 放入二级缓存,并且移除三级缓存的对象(不再需要lambda表达式) --------------&gt;AService普通对象 2.3 添加其他属性 2.4 其他步骤 2.5 放入单例池Map&lt;beanName, AService Bean对象&gt; 3.填充cService属性 创建CService 3.1 new CService() ---&gt; BService普通对象 3.2 添加aService属性 ---&gt; 单例池Map ---&gt;找不到 ---&gt; creatingSet ---&gt; AService循环依赖 ---&gt;第二级 3.3 添加其他属性 3.4 其他步骤 3.5 放入单例池Map&lt;beanName, AService Bean对象&gt; 4.其他步骤(AOP) ---&gt;AService 代理对象(?) ---&gt;判断是否提前进行了AOP若是则返回普通对象，否则进行AOP返回代理对象5.把二级缓存对象放入一级缓存单例池Map&lt;beanName, AService Bean对象&gt;，并移除二级缓存对象注意：普通对象没有值是一个半成品；Bean对象有值，是一个完整体 三级缓存第一级缓存：singletonObjects 单例池 保证bean对象的单例效果 第二级缓存：earlySingletonObjects 保证单例效果，但是此时的对象还不是完整体 第三级缓存：singletonFactories 打破循环 哪些情况spring不能解决循环依赖构造注入,spring无法解决这样的循环依赖，无法产生基本的普通对象 1234567891011121314151617@Componentpublic class AService()&#123; public BService bService; @Autowired public AService(BService bService)&#123; this.bService=bService; &#125;&#125;@Componentpublic class BService()&#123; public AService aService; @Autowired public BService(AService aService)&#123; this.aService=aService; &#125;&#125; 针对上述情况需要用@Lazy注解来解决，会产生一个BService的代理对象,不会进入对BService属性赋值的逻辑 123456789101112131415161718@Componentpublic class AService()&#123; public BService bService; @Autowired @Lazy public AService(BService bService)&#123; //BService代理对象 this.bService=bService; &#125;&#125;@Componentpublic class BService()&#123; public AService aService; @Autowired public BService(AService aService)&#123; this.aService=aService; &#125;&#125; 源码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176AbstractAutowireCapableBeanFactory.class protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; instanceWrapper = this.createBeanInstance(beanName, mbd, args); &#125; Object bean = instanceWrapper.getWrappedInstance(); Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) &#123; mbd.resolvedTargetType = beanType; &#125; synchronized(mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable var17) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, var17); &#125; mbd.postProcessed = true; &#125; &#125; boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName); if (earlySingletonExposure) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName + &quot;&#x27; to allow for resolving potential circular references&quot;); &#125; //如果支持循环依赖，则生成三级缓存，提前暴露bean this.addSingletonFactory(beanName, () -&gt; &#123; return this.getEarlyBeanReference(beanName, mbd, bean); &#125;); &#125; Object exposedObject = bean; try &#123; //填充属性，循环依赖在这个阶段产生 this.populateBean(beanName, mbd, instanceWrapper); //执行初始化方法 exposedObject = this.initializeBean(beanName, exposedObject, mbd); &#125; catch (Throwable var18) &#123; if (var18 instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) &#123; throw (BeanCreationException)var18; &#125; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, var18); &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = this.getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; //把原始bean 置换为代理对象 exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) &#123; String[] dependentBeans = this.getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length); String[] var12 = dependentBeans; int var13 = dependentBeans.length; for(int var14 = 0; var14 &lt; var13; ++var14) &#123; String dependentBean = var12[var14]; if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;); &#125; &#125; &#125; &#125; try &#123; this.registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject; &#125; catch (BeanDefinitionValidationException var16) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, var16); &#125; &#125;DefaultSingletonBeanRegistry.class @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; //首先从一级缓存里面获取对象 Object singletonObject = this.singletonObjects.get(beanName); //一级缓存找不到而且对象正在创建中 if (singletonObject == null &amp;&amp; this.isSingletonCurrentlyInCreation(beanName)) &#123; //加锁 synchronized(this.singletonObjects) &#123; //从二级缓存找 singletonObject = this.earlySingletonObjects.get(beanName); //二级缓存找不到，并且允许循环依赖 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; //从三级缓存找到一个lambda表达式，实质是一个对象工厂 ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; //执行三级缓存里的lambda表达式，通过工厂方法来创建对象 singletonObject = singletonFactory.getObject(); //把创建的对象放入二级缓存中 this.earlySingletonObjects.put(beanName, singletonObject); //并且移除三级缓存的普通对象 this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject; &#125; public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, &quot;Bean name must not be null&quot;); synchronized(this.singletonObjects) &#123; Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; if (this.singletonsCurrentlyInDestruction) &#123; throw new BeanCreationNotAllowedException(beanName, &quot;Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;); &#125; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;Creating shared instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; // 标记bean创建中 this.beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = this.suppressedExceptions == null; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = new LinkedHashSet(); &#125; try &#123; singletonObject = singletonFactory.getObject(); newSingleton = true; &#125; catch (IllegalStateException var16) &#123; singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; throw var16; &#125; &#125; catch (BeanCreationException var17) &#123; BeanCreationException ex = var17; if (recordSuppressedExceptions) &#123; Iterator var8 = this.suppressedExceptions.iterator(); while(var8.hasNext()) &#123; Exception suppressedException = (Exception)var8.next(); ex.addRelatedCause(suppressedException); &#125; &#125; throw ex; &#125; finally &#123; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = null; &#125; this.afterSingletonCreation(beanName); &#125; if (newSingleton) &#123; this.addSingleton(beanName, singletonObject); &#125; &#125; return singletonObject; &#125; &#125; 三级缓存里lambda表达式的工厂方法 1234567891011121314151617protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123; Object exposedObject = bean; //会判断是否需要提前AOP 如果是则返回代理对象，否则直接返回普通对象 if (!mbd.isSynthetic() &amp;&amp; this.hasInstantiationAwareBeanPostProcessors()) &#123; Iterator var5 = this.getBeanPostProcessors().iterator(); while(var5.hasNext()) &#123; BeanPostProcessor bp = (BeanPostProcessor)var5.next(); if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123; SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor)bp; exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName); &#125; &#125; &#125; return exposedObject; &#125; 链接 http://ulemony.github.io/posts/a5d86a59.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://ulemony.github.io/tags/spring/"}]},{"title":"SpringBoot整合Redis","slug":"SpringBoot整合Redis","date":"2024-01-23T14:14:44.000Z","updated":"2024-01-23T17:39:11.772Z","comments":true,"path":"posts/4ebad2d4.html","link":"","permalink":"http://ulemony.github.io/posts/4ebad2d4.html","excerpt":"SpringBoot整合RedisPom依赖123456789101112131415161718192021&lt;dependencies&gt; &lt;!--集成redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--序列化--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok,自动生成set、get等方法--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 自定义封装RedisTemplate1234567891011121314151617181920212223242526272829303132333435363738import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(&quot;all&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; // 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); // Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // String 的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125;","text":"SpringBoot整合RedisPom依赖123456789101112131415161718192021&lt;dependencies&gt; &lt;!--集成redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--序列化--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok,自动生成set、get等方法--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 自定义封装RedisTemplate1234567891011121314151617181920212223242526272829303132333435363738import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(&quot;all&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; // 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); // Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // String 的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; RedisUtils类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import javax.annotation.Resource;import java.util.Collection;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;@Componentpublic final class RedisUtil &#123; @Resource private RedisTemplate&lt;String, Object&gt; redisTemplate; public Set&lt;String&gt; keys(String keys)&#123; try &#123; return redisTemplate.keys(keys); &#125;catch (Exception e)&#123; e.printStackTrace(); return null; &#125; &#125; /** * 指定缓存失效时间 * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据key 获取过期时间 * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key) &#123; return redisTemplate.getExpire(key, TimeUnit.SECONDS); &#125; /** * 判断key是否存在 * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key) &#123; try &#123; return redisTemplate.hasKey(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除缓存 * @param key 可以传一个值 或多个 */ @SuppressWarnings(&quot;unchecked&quot;) public void del(String... key) &#123; if (key != null &amp;&amp; key.length &gt; 0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key)); &#125; &#125; &#125; /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入, 不存在放入，存在返回 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean setnx(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().setIfAbsent(key,value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间,不存在放入，存在返回 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean setnx(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().setIfAbsent(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 递增 * @param key 键 * @param delta 要增加几(大于0) * @return */ public long incr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(&quot;递增因子必须大于0&quot;); &#125; return redisTemplate.opsForValue().increment(key, delta); &#125; /** * 递减 * @param key 键 * @param delta 要减少几(小于0) * @return */ public long decr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(&quot;递减因子必须大于0&quot;); &#125; return redisTemplate.opsForValue().increment(key, -delta); &#125; /** * HashGet * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key, String item) &#123; return redisTemplate.opsForHash().get(key, item); &#125; /** * 获取hashKey对应的所有键值 * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object, Object&gt; hmget(String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * HashSet * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * HashSet 并设置时间 * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value, long time) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除hash表中的值 * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item) &#123; redisTemplate.opsForHash().delete(key, item); &#125; /** * 判断hash表中是否有该项的值 * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item) &#123; return redisTemplate.opsForHash().hasKey(key, item); &#125; /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, by); &#125; /** * hash递减 * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, -by); &#125; /** * 根据key获取Set中的所有值 * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key) &#123; try &#123; return redisTemplate.opsForSet().members(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 根据value从一个set中查询,是否存在 * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key, Object value) &#123; try &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将数据放入set缓存 * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object... values) &#123; try &#123; return redisTemplate.opsForSet().add(key, values); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 将set数据放入缓存 * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key, long time, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().add(key, values); if (time &gt; 0)&#123; expire(key, time); &#125; return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 获取set缓存的长度 * @param key 键 * @return */ public long sGetSetSize(String key) &#123; try &#123; return redisTemplate.opsForSet().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 移除值为value的 * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().remove(key, values); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; // ===============================list================================= /** * 获取list缓存的内容 * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end) &#123; try &#123; return redisTemplate.opsForList().range(key, start, end); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 获取list缓存的长度 * @param key 键 * @return */ public long lGetListSize(String key) &#123; try &#123; return redisTemplate.opsForList().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 通过索引 获取list中的值 * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key, long index) &#123; try &#123; return redisTemplate.opsForList().index(key, index); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, Object value) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0)&#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; value) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0)&#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据索引修改list中的某条数据 * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index, Object value) &#123; try &#123; redisTemplate.opsForList().set(key, index, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 移除N个值为value * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key, long count, Object value) &#123; try &#123; Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125;&#125; 链接 http://ulemony.github.io/posts/4ebad2d4.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://ulemony.github.io/tags/redis/"}]},{"title":"Redis基础","slug":"Redis基础","date":"2024-01-23T14:10:52.000Z","updated":"2024-01-23T16:30:08.464Z","comments":true,"path":"posts/fe29e710.html","link":"","permalink":"http://ulemony.github.io/posts/fe29e710.html","excerpt":"Redis基础Redis五大数据类型String添加 1set key value","text":"Redis基础Redis五大数据类型String添加 1set key value 查询 1get key 查询当前库所有数据 1keys * 判断某个key是否存在，存在返回1，不存在返回0 1EXISTS key 对key的值追加拼接数据 1APPEND key value 查看数据长度 1STRLEN key 递增数值, 应用场景：网站访问次数，收藏数 12INCR keyINCRBY key num 指定数值递增 递减数值 12DECR keyDECRBY key num 指定数值递减 截取 1GETRANGE key 0 4 获取字符串下标从0开始，包含下标4 替换 1SETRANGE key 5 88 把下标为5的元素替换为88 同时设置&#x2F;获取多个键值对 12MSET key value [key value...] 设置MGET key [key...] 获取 分布式锁 1234567SETNX key value 不存在才设置SET key value [EX seconds] [PX milliseconds] [NX|XX]EX：key在多少秒之后过期PX：key在多少毫秒之后过期NX：当key不存在的时候，才创建key，效果等同于setnxXX：当key存在的时候，覆盖key list左添加 1LPUSH key value[value...] 右添加 1RPUSH key value[value...] 查看列表 1LRANGE key start stop 获取列表元素个数 1LLEN key 左移除 1lpop key 右移除 1rpop key 查询指定下标元素 1lindex key 1 查询下标为1的元素 移除 1lrem key 3 v2 移除集合中元素“v2”的元素3个 截取 1ltrim key start stop 只保留截取后的元素【start，stop】 更新 1lset key index newValue 将下标为index的元素更新为新值 hash相当于Java中Map&lt;String,Map&lt;object,object&gt;&gt; 123456应用场景：购物车新增商品 hset shopcar:uid1024 334488 1新增商品 hset shopcar:uid1024 334477 1增加商品数量 hincrby shopcar:uid1024 334477 1商品总数 hlen shopcar:uid1024全部选择 hgetall shopcar:uid1024 添加 12hset key field 添加一个hmset key field value[field value] 添加多个 查询 12hget key fieldhmget key field[field] 删除 1hdel key field[field] 获取长度 1hlen key 判断是否存在 1hexists key field 获取指定hash中所有key 1hkeys key 获取指定hash中所有value 1hvals key 增加 1hincrby key field increment Set无序；应用场景：抽奖、朋友圈点赞、社交关系、可能认识的人 添加 1sadd key member [member] 删除 1srem key member 获取所有元素 1smembers key 判断元素是否在集合中 1sismember key member 获取元素个数 1scard key 随机弹出元素，但不删除 1srandmember key [count] 随机弹出元素并删除 1spop key [count] 集合运算 123sinter key [key] 交集sdiff key [key] 差集sunion key [key] 并集 zset有序；应用场景：热搜、商品排序 添加 1zadd key score member [score member] 排序小-大 1zrange key start stop [withscores] 获取指定分数范围元素 12345zrangebyscore key min max [withscores] [limit offset count]min 和 max: 这两个参数用于指定分数范围的下限和上限，你可以使用 -inf 表示负无穷大，+inf 表示正无穷大。指定范围内的成员将会被检索。[withscores]: 这是一个可选参数，如果包含这个参数，那么返回的结果将包括成员的分数。如果不包含这个参数，只会返回成员的值。[limit offset count]: 这也是一个可选参数，用于限制返回的结果数量。offset 表示从匹配到的成员列表中的第几个成员开始返回结果，count 表示最多返回的成员数量。这个参数允许你进行分页查询，从匹配的成员中获取一部分。 增加某个元素分数 1zincrby key increment member 获取集合元素个数 1zcard key 获取指定范围元素个数 1zcount key min max 删除元素 1zrem key member [member] 按照排名范围删除元素 1zremrangebyrank key start stop 获取元素排名 12zrank key member 小-大zrevrank key member 大-小 链接 http://ulemony.github.io/posts/fe29e710.html","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ulemony.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://ulemony.github.io/tags/redis/"}]},{"title":"Docker常见命令","slug":"Docker常见命令","date":"2024-01-23T14:01:36.000Z","updated":"2024-01-23T14:42:44.542Z","comments":true,"path":"posts/a70288e8.html","link":"","permalink":"http://ulemony.github.io/posts/a70288e8.html","excerpt":"Docker常见命令添加阿里云镜像 1sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装命令 1sudo yum install -y docker-ce docker-ce-cli containerd.io","text":"Docker常见命令添加阿里云镜像 1sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装命令 1sudo yum install -y docker-ce docker-ce-cli containerd.io 启动命令 1sudo systemctl start docker 添加当前用户到docker用户组： 123sudo usermod -aG docker $USER （需注销）newgrp docker （立即生效） pull nginx 镜像 1docker pull nginx（等效于nginx:latest） 运行 1docker run -【d】（后台运行不阻塞shell） 【-p 80:80】（指定容器端口映射，内部：外部） nginx 查看正在运行 1docker ps 查看本地容器ID 1docker ps -a 删除容器 1docker rm -f &lt;container id(不用打全，前缀区分)&gt; 进入bash 1docker exec -it &lt;container id(不用打全，前缀区分)&gt; bash commit镜像 1docker commit &lt;container id(不用打全，前缀区分)&gt; &lt;name&gt; 查看镜像列表 1docker images （刚才commit的镜像） 使用运行刚才commit的镜像 1docker run -d &lt;name&gt; 使用Dockerfile构建镜像 1docker build -t &lt;name&gt; &lt;存放Dockerfile的文件夹&gt; 删除镜像 1docker rmi &lt;name&gt; 保存为tar 1docker save &lt;name&gt; &gt; &lt;tar name&gt; 从tar加载 1docker load &lt; &lt;tar name&gt; 一些启动参数： 1234567后台运行容器：-d容器内外端口映射：-p 内部端口号:外部端口号目录映射：-v &#x27;dir name&#x27; : &lt;dir&gt;指定映像版本：&lt;name&gt;:&lt;ver&gt; Docker容器中的文件拷贝至本地 #格式 docker cp CONTAINER ID:容器目录 本地目录 1sudo docker cp 52ea915e6527:/aha /home/aha2 本地文件拷贝至容器 #格式 docker cp 本地路径 CONTAINER ID:容器目录 1docker cp license.dat 52ea915e6527:/home 链接 http://ulemony.github.io/posts/a70288e8.html","categories":[{"name":"容器","slug":"容器","permalink":"http://ulemony.github.io/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://ulemony.github.io/tags/docker/"}]},{"title":"Dockerfile用法","slug":"Dockerfile用法","date":"2024-01-23T13:56:02.000Z","updated":"2024-01-23T14:42:44.529Z","comments":true,"path":"posts/387270af.html","link":"","permalink":"http://ulemony.github.io/posts/387270af.html","excerpt":"Dockerfile用法常见配置From XXX（基于什么镜像）WORKDIR（指定shell语句运行在那个路径下）COPY（将宿主机的文件拷贝到某路径下）RUN（运行shell语句，只要构建就会运行，如echo 321 &gt;&gt; 1.txt）CMD （指定镜像启动运行的脚本，只有容器真正运行的时候才会运行的脚本，执行后容器的生命周期即结束，且一般为阻塞式语句，如tail语句） 一般语句为：FROM WORKDIR COPY-ADD RUN CMD-ENTRYPOINTENTRYPOINT非json则以ENTRYPOT为准，如果ENTRYPOINT和CMD都是JSON则ENTRYPOINT+CMD拼接成shell EXPOSE—暴露镜像的指定端口VOLUME—指定映射文件ENV—指定doker的环境变量，运行时一直生效ARG—构建参数，运行时无效，可以构建时候临时修改变量LABEL—指定元数据，便于找到dockerONBUILD—当前镜像构建的时候不会执行，基于当前镜像的镜像去构建的时候才会执行STOPSIGNAL—指定容器使用什么信号，一般指定信号名HEALTHCHECK—检查容易的健康状态SHELL—指定linux为&#x2F;bin&#x2F;sh，windows为cmd","text":"Dockerfile用法常见配置From XXX（基于什么镜像）WORKDIR（指定shell语句运行在那个路径下）COPY（将宿主机的文件拷贝到某路径下）RUN（运行shell语句，只要构建就会运行，如echo 321 &gt;&gt; 1.txt）CMD （指定镜像启动运行的脚本，只有容器真正运行的时候才会运行的脚本，执行后容器的生命周期即结束，且一般为阻塞式语句，如tail语句） 一般语句为：FROM WORKDIR COPY-ADD RUN CMD-ENTRYPOINTENTRYPOINT非json则以ENTRYPOT为准，如果ENTRYPOINT和CMD都是JSON则ENTRYPOINT+CMD拼接成shell EXPOSE—暴露镜像的指定端口VOLUME—指定映射文件ENV—指定doker的环境变量，运行时一直生效ARG—构建参数，运行时无效，可以构建时候临时修改变量LABEL—指定元数据，便于找到dockerONBUILD—当前镜像构建的时候不会执行，基于当前镜像的镜像去构建的时候才会执行STOPSIGNAL—指定容器使用什么信号，一般指定信号名HEALTHCHECK—检查容易的健康状态SHELL—指定linux为&#x2F;bin&#x2F;sh，windows为cmd Demo12345678FROM alpineLABEl k=&quot;v&quot; k1=&quot;v1&quot;WORKDIR /appCOPY src/ /appRUN echo helloword &gt;&gt; 1.txtARG B=11ONBUILD ENV C=100CMD echo $C 构建镜像使用Dockerfile构建镜像：docker build -t &lt;存放Dockerfile的文件夹&gt; 例如：在当前文件夹构建名为test的镜像 1docker build -t test . 链接 http://ulemony.github.io/posts/387270af.html","categories":[{"name":"容器","slug":"容器","permalink":"http://ulemony.github.io/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://ulemony.github.io/tags/docker/"}]},{"title":"Jvm指令和工具","slug":"Jvm指令和工具","date":"2024-01-23T13:37:18.000Z","updated":"2024-01-23T16:39:03.844Z","comments":true,"path":"posts/817f8310.html","link":"","permalink":"http://ulemony.github.io/posts/817f8310.html","excerpt":"Jvm指令和工具jps 查看java进程 123lee@lee-mac ~ % jps63266 miniLegionInit.jar63964 Jps jconsole","text":"Jvm指令和工具jps 查看java进程 123lee@lee-mac ~ % jps63266 miniLegionInit.jar63964 Jps jconsoleJava监视和管理平台 1jconsole jstat查看内存 常用命令112345678910111213141516jstat -gcutil pid intervalpid:进程interval: 间隔时间lee@lee-mac ~ % jstat -gcutil 63266 1000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 常用命令21234jstat -gc pidlee@lee-mac ~ % jstat -gc 63266 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 6656.0 7680.0 0.0 0.0 71680.0 63287.4 90624.0 13323.2 35496.0 33765.1 4608.0 4304.3 10 0.079 2 0.202 0.281 常用命令31234jstat -gcnew pidlee@lee-mac ~ % jstat -gcnew 63266 S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT 6656.0 7680.0 0.0 0.0 1 15 7680.0 71680.0 63287.4 10 0.079 常用命令41234jstat -gcold pidlee@lee-mac ~ % jstat -gcold 63266 MC MU CCSC CCSU OC OU YGC FGC FGCT GCT 35496.0 33765.1 4608.0 4304.3 90624.0 13323.2 10 2 0.202 0.281 jstack分析线程运行状况 1jstack pid 但是jconsole已经集成jstack和jstat的功能 jmap可以把堆情况dump下来 然后用软件查看文件信息 123jmap -dump:file=a pid例如jmap -dump:file=a 63266 打印当前进程堆内存信息 1jmap -heap pid VisualVMjava虚拟机监控工具 启动1.进入jdk安装目录的bin目录，双击打开jvisualvm 2.终端模式下输入命令 1jvisualvm 链接 http://ulemony.github.io/posts/817f8310.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://ulemony.github.io/tags/jvm/"}]},{"title":"springsecurity之@PreAuthorize讲解","slug":"springsecurity之-PreAuthorize讲解","date":"2024-01-22T02:37:45.000Z","updated":"2024-01-23T16:39:10.998Z","comments":true,"path":"posts/9d7a9baf.html","link":"","permalink":"http://ulemony.github.io/posts/9d7a9baf.html","excerpt":"@PreAuthorize注解使用讲解@PreAuthorize 可以在方法前进行权限验证，如果没有对应权限则无法执行方法，下面是使用案例 a.在对应方法使用@PreAuthorize注解，值为EL表达式123456@ApiOperation(&quot;导出用户数据&quot;)@GetMapping(value = &quot;/download&quot;)@PreAuthorize(&quot;@el.check(&#x27;user:list&#x27;)&quot;)public void exportUser(HttpServletResponse response, UserQueryCriteria criteria) throws IOException &#123; userService.download(userService.queryAll(criteria), response);&#125; b.在SpringSecurityConfig上使用注解@EnableGlobalMethodSecurity","text":"@PreAuthorize注解使用讲解@PreAuthorize 可以在方法前进行权限验证，如果没有对应权限则无法执行方法，下面是使用案例 a.在对应方法使用@PreAuthorize注解，值为EL表达式123456@ApiOperation(&quot;导出用户数据&quot;)@GetMapping(value = &quot;/download&quot;)@PreAuthorize(&quot;@el.check(&#x27;user:list&#x27;)&quot;)public void exportUser(HttpServletResponse response, UserQueryCriteria criteria) throws IOException &#123; userService.download(userService.queryAll(criteria), response);&#125; b.在SpringSecurityConfig上使用注解@EnableGlobalMethodSecurity123456@Configuration@EnableWebSecurity@RequiredArgsConstructor//开启prePostEnabled和securedEnabled@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)public class SpringSecurityConfig extends WebSecurityConfigurerAdapter &#123; c.对el表达式进行处理12345678910@Service(value = &quot;el&quot;)public class AuthorityConfig &#123; public Boolean check(String ...permissions)&#123; // 获取当前用户的所有权限 List&lt;String&gt; elPermissions = SecurityUtils.getCurrentUser().getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.toList()); // 判断当前用户为admin或者含有对应权限则验证通过 return elPermissions.contains(&quot;admin&quot;) || Arrays.stream(permissions).anyMatch(elPermissions::contains); &#125;&#125; @PreAuthorize源码讲解首先看该注解的代码 1234567@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface PreAuthorize &#123; String value();&#125; 该注解并不能直接进行权限验证，那它是怎么生效的呢？主要靠注解@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true, securedEnabled &#x3D; true)，它通过Import导入了GlobalMethodSecuritySelector.class，而在这个类中注册了GlobalMethodSecurityConfiguration.class GlobalMethodSecuritySelector.class关键源码1234567891011121314151617181920212223242526272829303132333435final class GlobalMethodSecuritySelector implements ImportSelector &#123; GlobalMethodSecuritySelector() &#123; &#125; public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; Class&lt;EnableGlobalMethodSecurity&gt; annoType = EnableGlobalMethodSecurity.class; Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(annoType.getName(), false); AnnotationAttributes attributes = AnnotationAttributes.fromMap(annotationAttributes); Assert.notNull(attributes, () -&gt; &#123; return String.format(&quot;@%s is not present on importing class &#x27;%s&#x27; as expected&quot;, annoType.getSimpleName(), importingClassMetadata.getClassName()); &#125;); Class&lt;?&gt; importingClass = ClassUtils.resolveClassName(importingClassMetadata.getClassName(), ClassUtils.getDefaultClassLoader()); boolean skipMethodSecurityConfiguration = GlobalMethodSecurityConfiguration.class.isAssignableFrom(importingClass); AdviceMode mode = (AdviceMode)attributes.getEnum(&quot;mode&quot;); boolean isProxy = AdviceMode.PROXY == mode; String autoProxyClassName = isProxy ? AutoProxyRegistrar.class.getName() : GlobalMethodSecurityAspectJAutoProxyRegistrar.class.getName(); boolean jsr250Enabled = attributes.getBoolean(&quot;jsr250Enabled&quot;); List&lt;String&gt; classNames = new ArrayList(4); if (isProxy) &#123; classNames.add(MethodSecurityMetadataSourceAdvisorRegistrar.class.getName()); &#125; classNames.add(autoProxyClassName); if (!skipMethodSecurityConfiguration) &#123; //注册了GlobalMethodSecurityConfiguration.class classNames.add(GlobalMethodSecurityConfiguration.class.getName()); &#125; if (jsr250Enabled) &#123; classNames.add(Jsr250MetadataSourceConfiguration.class.getName()); &#125; return (String[])classNames.toArray(new String[0]); &#125;&#125; GlobalMethodSecurityConfiguration.class关键源码这个类非常关键，负责生成权限验证所需要的拦截器、权限管理器、EL表达式处理器 123456789101112131415161718192021222324252627282930313233343536373839404142GlobalMethodSecurityConfiguration.class @Beanpublic MethodInterceptor methodSecurityInterceptor(MethodSecurityMetadataSource methodSecurityMetadataSource) &#123; this.methodSecurityInterceptor = (MethodSecurityInterceptor)(this.isAspectJ() ? new AspectJMethodSecurityInterceptor() : new MethodSecurityInterceptor()); //设置访问决策管理器 this.methodSecurityInterceptor.setAccessDecisionManager(this.accessDecisionManager()); this.methodSecurityInterceptor.setAfterInvocationManager(this.afterInvocationManager()); //设置安全元数据源 用于获取方法级别的安全性配置信息 this.methodSecurityInterceptor.setSecurityMetadataSource(methodSecurityMetadataSource); RunAsManager runAsManager = this.runAsManager(); if (runAsManager != null) &#123; this.methodSecurityInterceptor.setRunAsManager(runAsManager); &#125; return this.methodSecurityInterceptor;&#125;//这段代码的作用是根据配置创建一个 AccessDecisionManager 实例，并配置其中的访问决策投票者。这些投票者负责根据不同的投票逻辑，决定用户是否有权限执行某个方法 protected AccessDecisionManager accessDecisionManager() &#123; List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters = new ArrayList();//@EnableGlobalMethodSecurity注解需要开启prePostEnabled = true,如果启用了 Pre-Post 注解（@PreAuthorize 和 @PostAuthorize），则创建并添加一个基于表达式的 Pre-Invocation 投票者 if (this.prePostEnabled()) &#123; ExpressionBasedPreInvocationAdvice expressionAdvice = new ExpressionBasedPreInvocationAdvice(); //获取El表达式处理器 expressionAdvice.setExpressionHandler(this.getExpressionHandler()); decisionVoters.add(new PreInvocationAuthorizationAdviceVoter(expressionAdvice)); &#125; if (this.jsr250Enabled()) &#123; decisionVoters.add(new Jsr250Voter()); &#125; RoleVoter roleVoter = new RoleVoter(); GrantedAuthorityDefaults grantedAuthorityDefaults = (GrantedAuthorityDefaults)this.getSingleBeanOrNull(GrantedAuthorityDefaults.class); if (grantedAuthorityDefaults != null) &#123; roleVoter.setRolePrefix(grantedAuthorityDefaults.getRolePrefix()); &#125; decisionVoters.add(roleVoter); decisionVoters.add(new AuthenticatedVoter()); //这些投票者被组合到 AffirmativeBased 决策管理器中。 return new AffirmativeBased(decisionVoters); &#125; 权限生效源码分析上面介绍了和权限相关的核心类，下面分析权限验证是怎么生效的 a. 获取安全元数据信息首先执行MethodSecurityInterceptor 父类AbstractSecurityInterceptor的beforeInvocation方法获取安全元数据信息 123AbstractSecurityInterceptor.class Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource().getAttributes(object); 由PrePostAnnotationSecurityMetadataSource 类进行获取 1234567891011121314151617PrePostAnnotationSecurityMetadataSource.class public Collection&lt;ConfigAttribute&gt; getAttributes(Method method, Class&lt;?&gt; targetClass) &#123; if (method.getDeclaringClass() == Object.class) &#123; return Collections.emptyList(); &#125; else &#123; PreFilter preFilter = (PreFilter)this.findAnnotation(method, targetClass, PreFilter.class); //处理注解@PreAuthorize PreAuthorize preAuthorize = (PreAuthorize)this.findAnnotation(method, targetClass, PreAuthorize.class); PostFilter postFilter = (PostFilter)this.findAnnotation(method, targetClass, PostFilter.class); PostAuthorize postAuthorize = (PostAuthorize)this.findAnnotation(method, targetClass, PostAuthorize.class); //.....省略代码 //返回元数据 格式如下[authorize: &#x27;@el.check()&#x27;, filter: &#x27;null&#x27;, filterTarget: &#x27;null&#x27;] return attrs; &#125; &#125;&#125; b.进行权限验证接着在beforeInvocation方法中调用attemptAuthorization方法 1234567891011121314151617AbstractSecurityInterceptor.class private void attemptAuthorization(Object object, Collection&lt;ConfigAttribute&gt; attributes, Authentication authenticated) &#123; try &#123;//利用AccessDecisionManager，也就是前面GlobalMethodSecurityConfiguration.class中配置的AffirmativeBased 决策管理器进行权限检验 this.accessDecisionManager.decide(authenticated, object, attributes); &#125; catch (AccessDeniedException var5) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(LogMessage.format(&quot;Failed to authorize %s with attributes %s using %s&quot;, object, attributes, this.accessDecisionManager)); &#125; else if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Failed to authorize %s with attributes %s&quot;, object, attributes)); &#125; this.publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated, var5)); throw var5; &#125;&#125; c.决策管理器验证核心是voter执行vote方法进行投票 1234567891011121314151617181920212223242526272829public class AffirmativeBased extends AbstractAccessDecisionManager &#123; public AffirmativeBased(List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters) &#123; super(decisionVoters); &#125; public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException &#123; int deny = 0; Iterator var5 = this.getDecisionVoters().iterator(); while(var5.hasNext()) &#123; AccessDecisionVoter voter = (AccessDecisionVoter)var5.next(); //会利用PreInvocationAuthorizationAdviceVoter 进行投票 int result = voter.vote(authentication, object, configAttributes); switch(result) &#123; case -1: ++deny; break; case 1: return; &#125; &#125; if (deny &gt; 0) &#123; throw new AccessDeniedException(this.messages.getMessage(&quot;AbstractAccessDecisionManager.accessDenied&quot;, &quot;Access is denied&quot;)); &#125; else &#123; this.checkAllowIfAllAbstainDecisions(); &#125; &#125;&#125; d.EL表达式处理在PreInvocationAuthorizationAdviceVoter中执行vote方法，最终落实到自定义的el表达式处理逻辑 1234567891011PreInvocationAuthorizationAdviceVoter.class public int vote(Authentication authentication, MethodInvocation method, Collection&lt;ConfigAttribute&gt; attributes) &#123; PreInvocationAttribute preAttr = this.findPreInvocationAttribute(attributes); if (preAttr == null) &#123; return 0; &#125; else &#123; //调用before方法进入el表达式处理逻辑，如果返回true获得票数1 return this.preAdvice.before(authentication, method, preAttr) ? 1 : -1; &#125;&#125; 1234567891011121314ExpressionBasedPreInvocationAdvice.class //执行before方法public boolean before(Authentication authentication, MethodInvocation mi, PreInvocationAttribute attr) &#123; PreInvocationExpressionAttribute preAttr = (PreInvocationExpressionAttribute)attr; EvaluationContext ctx = this.expressionHandler.createEvaluationContext(authentication, mi); Expression preFilter = preAttr.getFilterExpression(); Expression preAuthorize = preAttr.getAuthorizeExpression(); if (preFilter != null) &#123; Object filterTarget = this.findFilterTarget(preAttr.getFilterTarget(), ctx, mi); this.expressionHandler.filter(filterTarget, preFilter, ctx); &#125;//进入自定义的el表达式处理逻辑，也就是上面AuthorityConfig 自定义的权限验证逻辑，如果有对应权限则返回true return preAuthorize != null ? ExpressionUtils.evaluateAsBoolean(preAuthorize, ctx) : true;&#125; e.投票结果回到上面的决策管理器AffirmativeBased 当投票结果result&#x3D;1时 直接return表示权限验证通过，否则++deny表示权限验证不通过，抛出AccessDeniedException异常，至此完成权限验证 12345678910111213141516171819202122232425AffirmativeBased.class public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException &#123; int deny = 0; Iterator var5 = this.getDecisionVoters().iterator(); while(var5.hasNext()) &#123; AccessDecisionVoter voter = (AccessDecisionVoter)var5.next(); // 当el表达式返回true时获得票数1否则为-1 int result = voter.vote(authentication, object, configAttributes); switch(result) &#123; case -1: ++deny; break; case 1: return; &#125; &#125;//deny大于0 表示权限验证不通过，抛出异常 if (deny &gt; 0) &#123; throw new AccessDeniedException(this.messages.getMessage(&quot;AbstractAccessDecisionManager.accessDenied&quot;, &quot;Access is denied&quot;)); &#125; else &#123; this.checkAllowIfAllAbstainDecisions(); &#125; &#125; 链接 http://ulemony.github.io/posts/9d7a9baf.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://ulemony.github.io/tags/SpringSecurity/"}]},{"title":"GPT-4体验","slug":"GPT-4体验","date":"2023-03-15T15:38:48.000Z","updated":"2023-03-15T17:30:50.000Z","comments":true,"path":"posts/e0a37648.html","link":"","permalink":"http://ulemony.github.io/posts/e0a37648.html","excerpt":"GPT-4今天openai发布了目前为止AI领域最先进的人工智能系统——GPT-4 于是申请注册体验，由于人太多，估计要等几个工作日，期待能通过申请 GPT-4可以做什么","text":"GPT-4今天openai发布了目前为止AI领域最先进的人工智能系统——GPT-4 于是申请注册体验，由于人太多，估计要等几个工作日，期待能通过申请 GPT-4可以做什么1.Creativity 创造力它可以生成、编辑和迭代用户进行创意和技术写作任务，例如创作歌曲、编写剧本或学习用户的写作风格。 例如我们输入要求让它解释灰姑娘的故事情节，它会根据要求生成相应的结果： 1234InputExplain the plot of Cinderella in a sentence where each word has to begin with the next letter in the alphabet from A to Z, without repeating any letters.用一个句子解释灰姑娘的情节，其中每个单词必须以字母表中从 A 到 Z 的下一个字母开头，不要重复任何字母 1234OutputA beautiful Cinderella, dwelling eagerly, finally gains happiness; inspiring jealous kin, love magically nurtures opulent prince; quietly rescues, slipper triumphs, uniting very wondrously, xenial youth zealously.美丽的灰姑娘，急切地栖息着，终于获得了幸福;激发嫉妒的亲人，爱情神奇地培育出华丽的王子;悄悄地营救，拖鞋胜利，团结得非常奇妙，青春热心。 这个功能对于写作辅助可谓一大利器，对于写论文、高考作文训练真是大大滴好呀！ 2.Visual input 图像输入GPT-4 根据输入的图像并生成标题、分类和分析，例如我们输入一张图片，询问它可以利用图片中的原材料做成什么食物 它会识别图片内容并给出建议：煎饼或华夫饼&#x2F;薄饼&#x2F;法式吐司&#x2F;煎蛋或煎蛋饼 （没有广东肠粉差评～-～） 如果你对有选择困难症，可以拍下自家的冰箱，让chatgt告诉你今天吃什么 PS：很好奇发一张九转大肠的图片给chatgt，它给的食谱会不会保留大肠原来的味道～-～ 3.Longer context 更长的文字处理GPT-4 能够处理超过 25，000 字的文本，允许使用长篇内容创建、扩展对话以及文档搜索和分析等用例。 打个比方，附上蕾哈娜的维基百科信息网址，让它分析蕾哈娜在超级碗中的表现以及过人之处： 1234Input[Text from: https://en.wikipedia.org/wiki/Rihanna]Describe her Super Bowl performance and what made it special. GPT-4会从长达几万字的维基百科介绍中提炼出如下结果： 123OutputRihanna&#x27;s Super Bowl LVII halftime show performance was special for a number of reasons. For one, it marked her first live performance in over five years, and it was her first time headlining the Super Bowl halftime show. Additionally, she made history by becoming the first person to perform at the Super Bowl while pregnant. The show itself was critically acclaimed, with many praising her high-energy performance and impressive vocals. It also garnered a massive viewership, becoming the second most-watched halftime show in history.蕾哈娜的超级碗LVII中场秀表演很特别，原因有很多。首先，这是她五年多来的第一次现场表演，这是她第一次在超级碗中场秀中担任头条新闻。此外，她创造了历史，成为第一个在怀孕期间在超级碗上表演的人。该节目本身广受好评，许多人称赞她的高能量表演和令人印象深刻的人声。它还获得了大量的收视率，成为历史上收视率第二高的中场秀。 GPT-4的亮点GPT-4在其先进的推理能力方面超过了上一个版本ChatGPT。 例如同一个问题，GPT-4比ChatGPT给出了更加精准的答案 123InputAndrew is free from 11 am to 3 pm, Joanne is free from noon to 2 pm and then 3:30 pm to 5 pm. Hannah is available at noon for half an hour, and then 4 pm to 6 pm. What are some options for start times for a 30 minute meeting for Andrew, Hannah, and Joanne?安德鲁从上午 11 点到下午 3 点有空，乔安妮从中午到下午 2 点，然后下午 3：30 到下午 5 点自由。汉娜在中午半小时可用，然后下午4点到6点。对于安德鲁、汉娜和乔安妮来说，30 分钟会议的开始时间有哪些选择？ ChatGPT给出的答案 12345678910111213OutputHere is a list of their availability:- Andrew: 11 am to 3 pm- Joanne: noon to 2 pm, and 3:30 pm to 5 pm- Hannah: noon to 12:30 pm, and 4 pm to 6 pmBased on their availability, there is a 30-minute window where all three of them are available, which is from 4 pm to 4:30 pm. So, the meeting can be scheduled at 4 pm.以下是它们的可用性列表：- 安德鲁：上午 11 点至下午 3 点- 乔安妮：中午至下午 2 点，下午 3：30 至下午 5 点- 汉娜：中午至下午 12：30，下午 4 点至下午 6 点根据他们的可用性，有一个 30 分钟的窗口，所有三个都可用，即下午 4 点到 4：30。因此，会议可以安排在下午 4 点。 GPT-4给出的答案 Andrew: 11 am - 3 pm Joanne: 12 pm - 2 pm, 3:30 pm - 5 pm Hannah: 12 pm - 12:30 pm, 4 pm - 6 pm Common availability for a 30-minute meeting: 12 pm - 12:30 pm安德鲁：上午 11 点至下午 3 点乔安妮：中午 12 点至下午 2 点，下午 3：30 至下午 5 点汉娜：中午12时至下午12时30分，下午4时至下午6时 30 分钟会议的通用可用性：中午 12 点至下午 12：30 人类未来的诗歌最后附上一首CHATGPT写的诗歌，人工智能在将会彻底颠覆人类社会的各个方面，希望这是写给人类的颂歌 链接 http://ulemony.github.io/posts/e0a37648.html","categories":[{"name":"AI","slug":"AI","permalink":"http://ulemony.github.io/categories/AI/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://ulemony.github.io/tags/ChatGPT/"}]},{"title":"Kafka常用命令","slug":"Kafka常用命令","date":"2023-02-10T15:46:45.000Z","updated":"2024-01-23T17:47:01.854Z","comments":true,"path":"posts/d25e2bb0.html","link":"","permalink":"http://ulemony.github.io/posts/d25e2bb0.html","excerpt":"进入容器 1docker exec -it 容器id bash 进入到kafka的安装目录，查看到kafka相关的命令 1cd /opt/kafka/bin/ topic操作","text":"进入容器 1docker exec -it 容器id bash 进入到kafka的安装目录，查看到kafka相关的命令 1cd /opt/kafka/bin/ topic操作创建一个topic12#添加名为test的topic 一个分区，3个副本,其中xxxx:2181为zookeeper的端口kafka-topics.sh --zookeeper xxxx:2181 --create --topic test --replication-factor 1 --partitions 3 执行后效果如下： 1Created topic test. 查询topic列表12#其中xxxx:2181为zookeeper的端口kafka-topics.sh --zookeeper xxxx:2181 --list 执行后效果如下 1test 查询topic详情12#查询名为test2的topic详情kafka-topics.sh --zookeeper xxxx:2181 --describe --topic test2 执行后效果如下 1234Topic: test2 TopicId: uly4F1d3SEyregeocjltZA PartitionCount: 3 ReplicationFactor: 1 Configs: Topic: test2 Partition: 0 Leader: 0 Replicas: 0 Isr: 0 Topic: test2 Partition: 1 Leader: 0 Replicas: 0 Isr: 0 Topic: test2 Partition: 2 Leader: 0 Replicas: 0 Isr: 0 删除topic12#删除名为test2的topickafka-topics.sh --zookeeper xxxx:2181 --delete --topic test2 执行后效果如下 12Topic test2 is marked for deletion.Note: This will have no impact if delete.topic.enable is not set to true. 发送消费消息生产者发送消息1kafka-console-producer.sh --broker-list localhost:9092 --topic example 执行后效果如下 12&gt;^Croot@f48c27085ce3:/opt/kafka/bin# kafka-console-producer.sh --broker-list localhost:9092 --topic example&gt;hello world！ 消费者消费消息1kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic example --from-beginning 执行后效果如下 1hello world！ 链接 http://ulemony.github.io/posts/d25e2bb0.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"kafka'","slug":"kafka","permalink":"http://ulemony.github.io/tags/kafka/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2023-02-09T02:16:12.000Z","updated":"2023-02-09T07:14:10.000Z","comments":true,"path":"posts/d0edc1ed.html","link":"","permalink":"http://ulemony.github.io/posts/d0edc1ed.html","excerpt":"Linux常用命令文件管理使用scp将一个Linux系统中的文件或文件夹复制到另一台Linux服务器上 复制文件1.将本地文件拷贝到远程主机","text":"Linux常用命令文件管理使用scp将一个Linux系统中的文件或文件夹复制到另一台Linux服务器上 复制文件1.将本地文件拷贝到远程主机 123//scp 文件名 用户名@计算机IP或者计算机名称:远程路径//192.168.1.12为远程服务器scp /root/install.* root@192.168.1.12:/usr/local/src 2.从远程将文件拷回本地 123//scp 用户名@计算机IP或者计算机名称:文件名 本地路径//本地192.168.1.8客户端取远程服务器12、11上的文件scp root@192.168.1.12:/usr/local/src/*.log /root/ 复制目录1.将本地文件夹拷贝到远程 123//scp -r 目录名 用户名@计算机IP或者计算机名称:远程路径//test1为源目录，test2为目标目录，zhidao@192.168.0.1为远程服务器的用户名和ip地址。scp -r /home/test1 zhidao@192.168.0.1:/home/test2 2.从远程拷贝目录回本地 123//scp -r 用户名@计算机IP或者计算机名称:目录名 本地路径//zhidao@192.168.0.1为远程服务器的用户名和ip地址，test1为源目录，test2为目标目录scp -r zhidao@192.168.0.1:/home/test2 /home/test1 链接 http://ulemony.github.io/posts/d0edc1ed.html","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ulemony.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ulemony.github.io/tags/Linux/"},{"name":"文件操作","slug":"文件操作","permalink":"http://ulemony.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]}],"categories":[{"name":"Database","slug":"Database","permalink":"http://ulemony.github.io/categories/Database/"},{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"},{"name":"Redis","slug":"Java/Redis","permalink":"http://ulemony.github.io/categories/Java/Redis/"},{"name":"Redis","slug":"Redis","permalink":"http://ulemony.github.io/categories/Redis/"},{"name":"容器","slug":"容器","permalink":"http://ulemony.github.io/categories/%E5%AE%B9%E5%99%A8/"},{"name":"AI","slug":"AI","permalink":"http://ulemony.github.io/categories/AI/"},{"name":"Linux","slug":"Linux","permalink":"http://ulemony.github.io/categories/Linux/"}],"tags":[{"name":"databas design","slug":"databas-design","permalink":"http://ulemony.github.io/tags/databas-design/"},{"name":"MySQL","slug":"MySQL","permalink":"http://ulemony.github.io/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"http://ulemony.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"索引","slug":"索引","permalink":"http://ulemony.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"jvm","slug":"jvm","permalink":"http://ulemony.github.io/tags/jvm/"},{"name":"缓存","slug":"缓存","permalink":"http://ulemony.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"异常处理","slug":"异常处理","permalink":"http://ulemony.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"mybatis","slug":"mybatis","permalink":"http://ulemony.github.io/tags/mybatis/"},{"name":"分页","slug":"分页","permalink":"http://ulemony.github.io/tags/%E5%88%86%E9%A1%B5/"},{"name":"mysql","slug":"mysql","permalink":"http://ulemony.github.io/tags/mysql/"},{"name":"mybatis plus","slug":"mybatis-plus","permalink":"http://ulemony.github.io/tags/mybatis-plus/"},{"name":"chatgpt","slug":"chatgpt","permalink":"http://ulemony.github.io/tags/chatgpt/"},{"name":"springboot","slug":"springboot","permalink":"http://ulemony.github.io/tags/springboot/"},{"name":"spring","slug":"spring","permalink":"http://ulemony.github.io/tags/spring/"},{"name":"redis","slug":"redis","permalink":"http://ulemony.github.io/tags/redis/"},{"name":"docker","slug":"docker","permalink":"http://ulemony.github.io/tags/docker/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://ulemony.github.io/tags/SpringSecurity/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://ulemony.github.io/tags/ChatGPT/"},{"name":"kafka'","slug":"kafka","permalink":"http://ulemony.github.io/tags/kafka/"},{"name":"Linux","slug":"Linux","permalink":"http://ulemony.github.io/tags/Linux/"},{"name":"文件操作","slug":"文件操作","permalink":"http://ulemony.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]}