{"meta":{"title":"阿木的博客","subtitle":"","description":"","author":"Jason Lee","url":"http://ulemony.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-02-09T02:09:39.000Z","updated":"2023-02-09T02:10:34.000Z","comments":true,"path":"categories/index.html","permalink":"http://ulemony.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-02-09T02:10:51.000Z","updated":"2023-02-09T02:11:19.000Z","comments":true,"path":"tags/index.html","permalink":"http://ulemony.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"chatgpt聊天机器人部署","slug":"chatgpt聊天机器人部署","date":"2024-01-23T14:27:18.000Z","updated":"2024-01-23T16:39:38.048Z","comments":true,"path":"posts/9fa1f056.html","link":"","permalink":"http://ulemony.github.io/posts/9fa1f056.html","excerpt":"window环境下的部署后端项目部署1.环境准备1.1 jdk1.8安装安装教程","text":"window环境下的部署后端项目部署1.环境准备1.1 jdk1.8安装安装教程 1https://blog.csdn.net/m0_70098804/article/details/131062308?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169028921016800225560646%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=169028921016800225560646&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~times_rank-1-131062308-null-null.142^v91^insertT0,239^v3^control&amp;utm_term=jdk1.8%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80&amp;spm=1018.2226.3001.4187 安装包下载地址 1https://www.oracle.com/cn/java/technologies/downloads/#java8-windows 1.2 maven3.9.3安装安装教程 1https://blog.csdn.net/weixin_44080187/article/details/122933194?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169029399616800226565364%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169029399616800226565364&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-122933194-null-null.142^v91^insertT0,239^v3^control&amp;utm_term=window%E5%AE%89%E8%A3%85maven&amp;spm=1018.2226.3001.4187 安装包下载地址 1https://maven.apache.org/download.cgi 1.3 微软语音服务获取a. Azure 订阅 - 免费创建订阅 b. 在 Azure 门户中创建语音资源 c. 获取语音资源密钥和区域。 部署语音资源后，选择“转到资源”以查看和管理密钥。 2.后端项目启动2.1 配置文件application.yaml修改修改工具：软件idea或者HBuilderX a.将openai的apiKey替换会你自己的apiKey 12openai: apiKey: xxxx b.将步骤1.3得到的语音密钥和区域设置成自己的密钥和区域 12345azure:#语音服务密钥 SPEECH_KEY: xxxx#语音服务地区 SERVICE_REGION: eastus c.在配置文件application.yaml中替换代理端口和地址 1234#代理地址和端口proxy: host: localhost port: 7890 2.2 修改语音文件保存路径a. 修改AudioUtil.java 文件 在本地电脑自定义新建文件夹 1234文件夹1C:\\audio\\input文件夹2C:\\audio\\output 将下图的两个语音路径替换成上面自定义的路径，注意路径需使用符号&#x2F; 即： 12345678// 构造原始音频文件保存目录 保存至电脑本地 String inputFilePath = &quot;/Users/lee/Desktop/audio/input&quot;; 修改为 String inputFilePath = &quot;C:/audio/input&quot;;//构建格式化后音频文件保存目录 String outputFilePath = &quot;/Users/lee/Desktop/audio/output&quot;; 修改为 String outputFilePath = &quot;C:/audio/output&quot;; b.修改TextToSpeechImpl.java文件 将下图的路径替换成自定义路径 1234//生成语音文件保存到本地 String outputFilePath=&quot;/Users/lee/Desktop/audio/output&quot;; 修改为 String outputFilePath=&quot;C:/audio/output&quot;; 2.3启动后端项目a.在命令窗口中cd进入项目根目录 1cd C:\\chatgpt-master-master b. 输入命令打包项目,初次打包会耗时较长时间 1mvn package c. 成功打包项目后会在项目中看到一个target目录，cd进入该目录 1cd C:\\chatgpt-master-master\\target d. 运行项目 电脑需要开启全局代理 1java -Xms64m -Xmx128m -jar miniLegionInit.jar 前端项目部署1.环境准备1.1 node环境安装具体安装教程 1https://blog.csdn.net/mengchuan6666/article/details/125893199?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=window%E5%AE%89%E8%A3%85vue4.5&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-125893199.142^v91^insertT0,239^v3^control&amp;spm=1018.2226.3001.4187 node.js安装包下载地址 1https://nodejs.org/dist/v14.17.0/ 我安装的版本是 node-v14.17.0-x64.msi 安装成功后查看版本号 1npm -v 1.2 NPM安装vue.js1npm install vue -g 1.3 全局安装vue-cli1npm install -g @vue/cli 2.前端项目启动2.1 修改ChatBox.vue文件将ip地址192.168.100.204替换成自己电脑的ip地址 2.2 启动前端项目a. 以管理员身份运行命令窗口，cd进入项目根目录 1cd C:\\chatgpt_vue-master b. 启动项目，注意先启动后端项目再启动前端项目 1npm run serve c. 启动成功后可以看到以下代码 1234DONE Compiled successfully in 15920ms 上午8:54:02 App running at: - Local: http://localhost:8081/ - Network: http://192.168.8.209:8081/ d.浏览器访问地址即可打开网页 1http://localhost:8081/ 链接 http://ulemony.github.io/posts/9fa1f056.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"chatgpt","slug":"chatgpt","permalink":"http://ulemony.github.io/tags/chatgpt/"}]},{"title":"SpringBoot自动配置原理","slug":"SpringBoot自动配置原理","date":"2024-01-23T14:24:06.000Z","updated":"2024-01-23T16:39:32.250Z","comments":true,"path":"posts/ec6e45b4.html","link":"","permalink":"http://ulemony.github.io/posts/ec6e45b4.html","excerpt":"Springboot自动配置原理 SpringBoot通过@EnableAutoConfiguration开启自动配置 利用@Import加载META-INF&#x2F;spring.factories配置文件中的所有自动配置类 这些配置类会根据@Conditionnal派生注解来生效 这些自动配置类会通过以Properties结尾命名的类获取全局配置文件中的属性 xxxProperties类通过@ConfigurationProperties注解和全局配置文件中的属性进行绑定 源码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration//通过该注解开启自动配置@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @AliasFor(annotation = EnableAutoConfiguration.class) Class&lt;?&gt;[] exclude() default &#123;&#125;; @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default &#123;&#125;; @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;) String[] scanBasePackages() default &#123;&#125;; @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage//注入类@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class&lt;?&gt;[] exclude() default &#123;&#125;; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default &#123;&#125;;&#125;AutoConfigurationImportSelector.class @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader //加载自动配置类 .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125;AutoConfigurationMetadataLoader.class public static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) &#123; return loadMetadata(classLoader, PATH); &#125; static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) &#123; try &#123; //实际上从&quot;META-INF/&quot; + &quot;spring-autoconfigure-metadata.properties&quot;下加载自动配置类 Enumeration&lt;URL&gt; urls = (classLoader != null) ? classLoader.getResources(path) : ClassLoader.getSystemResources(path); Properties properties = new Properties(); while (urls.hasMoreElements()) &#123; properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource(urls.nextElement()))); &#125; return loadMetadata(properties); &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(&quot;Unable to load @ConditionalOnClass location [&quot; + path + &quot;]&quot;, ex); &#125; &#125;@Configuration @Conditional(DefaultDispatcherServletCondition.class) @ConditionalOnClass(ServletRegistration.class)//从xxxProperties类中获取全局配置文件属性值 @EnableConfigurationProperties(&#123; HttpProperties.class, WebMvcProperties.class &#125;) protected static class DispatcherServletConfiguration //通过该注解和全局配置文件中的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;)public class HttpProperties 链接 http://ulemony.github.io/posts/ec6e45b4.html","text":"Springboot自动配置原理 SpringBoot通过@EnableAutoConfiguration开启自动配置 利用@Import加载META-INF&#x2F;spring.factories配置文件中的所有自动配置类 这些配置类会根据@Conditionnal派生注解来生效 这些自动配置类会通过以Properties结尾命名的类获取全局配置文件中的属性 xxxProperties类通过@ConfigurationProperties注解和全局配置文件中的属性进行绑定 源码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration//通过该注解开启自动配置@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @AliasFor(annotation = EnableAutoConfiguration.class) Class&lt;?&gt;[] exclude() default &#123;&#125;; @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default &#123;&#125;; @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;) String[] scanBasePackages() default &#123;&#125;; @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage//注入类@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class&lt;?&gt;[] exclude() default &#123;&#125;; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default &#123;&#125;;&#125;AutoConfigurationImportSelector.class @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader //加载自动配置类 .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125;AutoConfigurationMetadataLoader.class public static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) &#123; return loadMetadata(classLoader, PATH); &#125; static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) &#123; try &#123; //实际上从&quot;META-INF/&quot; + &quot;spring-autoconfigure-metadata.properties&quot;下加载自动配置类 Enumeration&lt;URL&gt; urls = (classLoader != null) ? classLoader.getResources(path) : ClassLoader.getSystemResources(path); Properties properties = new Properties(); while (urls.hasMoreElements()) &#123; properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource(urls.nextElement()))); &#125; return loadMetadata(properties); &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(&quot;Unable to load @ConditionalOnClass location [&quot; + path + &quot;]&quot;, ex); &#125; &#125;@Configuration @Conditional(DefaultDispatcherServletCondition.class) @ConditionalOnClass(ServletRegistration.class)//从xxxProperties类中获取全局配置文件属性值 @EnableConfigurationProperties(&#123; HttpProperties.class, WebMvcProperties.class &#125;) protected static class DispatcherServletConfiguration //通过该注解和全局配置文件中的属性进行绑定@ConfigurationProperties(prefix = &quot;spring.http&quot;)public class HttpProperties 链接 http://ulemony.github.io/posts/ec6e45b4.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://ulemony.github.io/tags/springboot/"}]},{"title":"Spring事务","slug":"Spring事务","date":"2024-01-23T14:22:14.000Z","updated":"2024-01-23T16:39:25.921Z","comments":true,"path":"posts/65703737.html","link":"","permalink":"http://ulemony.github.io/posts/65703737.html","excerpt":"Spring事务是如何实现的 Spring事务底层基于数据库事务和AOP机制 对使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean 调用代理对象的方法时，会先判断该方法是否有@Transactional注解，如果加了会利用事务管理器创建一个数据库连接，并且将数据库连接的autocommit属性设置为false，禁止连接自动提交 执行当前方法，方法中会执行sql，方法执行完后如果没有异常就提交事务；如果出现了异常则回滚事务，至于哪些异常回滚事务，可以通过@Transactional注解的rollbackFor进行配置，默认会对RuntimeException和erroe进行回滚 Spring事务隔离级别spring事务隔离级别就是数据库的隔离级别，它是基于数据库连接来做的，一个事务对应一个数据库连接，如果传播机制要新开事务，实际上是新建一个数据库连接来执行sql 1.read uncommitted 未提交读","text":"Spring事务是如何实现的 Spring事务底层基于数据库事务和AOP机制 对使用了@Transactional注解的Bean，Spring会创建一个代理对象作为Bean 调用代理对象的方法时，会先判断该方法是否有@Transactional注解，如果加了会利用事务管理器创建一个数据库连接，并且将数据库连接的autocommit属性设置为false，禁止连接自动提交 执行当前方法，方法中会执行sql，方法执行完后如果没有异常就提交事务；如果出现了异常则回滚事务，至于哪些异常回滚事务，可以通过@Transactional注解的rollbackFor进行配置，默认会对RuntimeException和erroe进行回滚 Spring事务隔离级别spring事务隔离级别就是数据库的隔离级别，它是基于数据库连接来做的，一个事务对应一个数据库连接，如果传播机制要新开事务，实际上是新建一个数据库连接来执行sql 1.read uncommitted 未提交读 2.read committed 提交读、不可重复读 3.repeatable read 可重复读 4.serializable 可串行化 Spring事务传播机制 REQUIRED：如果当前没有事务则新建一个事务，如果有就加入该事务 SUPPORTS：当前存在事务则加入该事务，没有则以非事务方法执行 MANDATORY：当前存在事务则加入该事务，没有则抛出异常 REQUIRED_NEW：创建一个新事务，如果当前存在事务则将其挂起 NOT_SUPPORTED：以非事务方式执行，如果当前存在事务则将其挂起 NEVER：不使用事务，如果当前存在事务则抛出异常 NESTED：如果当前事务存在，则在嵌套事务中执行，如果不存在事务则新建一个事务 事务失效 方法内自调用：Spring事务是基于AOP的，只有使用代理对象调用某个方法时，事务才生效，如果一个方法中使用this.xxx（）调用方法时，this不是代理对象，导致事务失效 a. 解决办法1: 把调用方法拆分到另外一个bean b. 解决办法2: 自己注入自己 c. 解决办法3: AopContext.currentProxy()+@EnableAspectJAutoProxy(exposeProxy&#x3D;true) 方法是private的：Spring事务基于CGLIB来进行AOP，而CGLIB基于父子类生效，子类是代理类，父类是被代理类，如果父类某个方法是private，子类没办法重写，也就不能增加spring事务的逻辑 方法是final的：原因同上 单独的线程：当Mybatis或JdbcTemplate执行sql时，会从ThreadLocal中获取数据库连接对象，如果开启事务的线程和执行sql的线程不是同一个线程，那么Mybatis或JdbcTemplate就会新建一个数据库连接来执行sql，此时autocommit为true，执行完sql便提交，后续即使抛出异常也不会进行回滚 spring事务没有捕捉到异常，从而不回滚 类没有被Spring管理 数据库不支持事务 链接 http://ulemony.github.io/posts/65703737.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://ulemony.github.io/tags/spring/"}]},{"title":"Spring之Bean的生命周期","slug":"Spring之Bean的生命周期","date":"2024-01-23T14:19:58.000Z","updated":"2024-01-23T16:39:20.898Z","comments":true,"path":"posts/c7e03167.html","link":"","permalink":"http://ulemony.github.io/posts/c7e03167.html","excerpt":"Bean的生命周期1.实例化实例化前实例化前,会执行InstantiationAwareBeanPostProcessor这种后置处理器的postProcessBeforeInstantiation方法，可以用于动态地创建或替换 bean 实例，从而实现更高级的定制和控制。 实例化前的部分源码","text":"Bean的生命周期1.实例化实例化前实例化前,会执行InstantiationAwareBeanPostProcessor这种后置处理器的postProcessBeforeInstantiation方法，可以用于动态地创建或替换 bean 实例，从而实现更高级的定制和控制。 实例化前的部分源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384AbstractAutowireCapableBeanFactory.class protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; RootBeanDefinition mbdToUse = mbd; Class&lt;?&gt; resolvedClass = this.resolveBeanClass(mbd, beanName, new Class[0]); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException var9) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, var9); &#125; Object beanInstance; try &#123; //实例化前 beanInstance = this.resolveBeforeInstantiation(beanName, mbdToUse); if (beanInstance != null) &#123; return beanInstance; &#125; &#125; catch (Throwable var10) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, var10); &#125; try &#123; //创建对象 beanInstance = this.doCreateBean(beanName, mbdToUse, args); if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; return beanInstance; &#125; catch (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123; throw var7; &#125; catch (Throwable var8) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, var8); &#125; &#125; @Nullable protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123; Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123; if (!mbd.isSynthetic() &amp;&amp; this.hasInstantiationAwareBeanPostProcessors()) &#123; Class&lt;?&gt; targetType = this.determineTargetType(beanName, mbd); if (targetType != null) &#123; bean = this.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) &#123; bean = this.applyBeanPostProcessorsAfterInitialization(bean, beanName); &#125; &#125; &#125; mbd.beforeInstantiationResolved = bean != null; &#125; return bean; &#125; @Nullable protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; Iterator var3 = this.getBeanPostProcessors().iterator(); while(var3.hasNext()) &#123; BeanPostProcessor bp = (BeanPostProcessor)var3.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; //会执行InstantiationAwareBeanPostProcessor这种后置处理器的postProcessBeforeInstantiation方法 Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) &#123; return result; &#125; &#125; &#125; return null; &#125; 实例化时的部分源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889AbstractAutowireCapableBeanFactory.class protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; //创建bean实例，推断构造方法 instanceWrapper = this.createBeanInstance(beanName, mbd, args); &#125; //创建bean Object bean = instanceWrapper.getWrappedInstance(); Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) &#123; mbd.resolvedTargetType = beanType; &#125; synchronized(mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable var17) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, var17); &#125; mbd.postProcessed = true; &#125; &#125; boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName); if (earlySingletonExposure) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName + &quot;&#x27; to allow for resolving potential circular references&quot;); &#125; this.addSingletonFactory(beanName, () -&gt; &#123; return this.getEarlyBeanReference(beanName, mbd, bean); &#125;); &#125; Object exposedObject = bean; try &#123; //属性填充 this.populateBean(beanName, mbd, instanceWrapper); //初始化bean exposedObject = this.initializeBean(beanName, exposedObject, mbd); &#125; catch (Throwable var18) &#123; if (var18 instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) &#123; throw (BeanCreationException)var18; &#125; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, var18); &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = this.getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) &#123; String[] dependentBeans = this.getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length); String[] var12 = dependentBeans; int var13 = dependentBeans.length; for(int var14 = 0; var14 &lt; var13; ++var14) &#123; String dependentBean = var12[var14]; if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;); &#125; &#125; &#125; &#125; try &#123; this.registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject; &#125; catch (BeanDefinitionValidationException var16) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, var16); &#125; &#125; 2.属性赋值在赋值的过程中会执行InstantiationAwareBeanPostProcessor这种后置处理器的postProcessAfterInstantiation方法，进行一些额外的控制或自定义操作。如果返回 false，则表示中断属性注入过程。 实现InstantiationAwareBeanPostProcessor接口重写postProcessProperties方法，在bean实例化后，属性注入前，可以根据属性描述，动态的新增，删除，修改一些属性。 属性填充源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788AbstractAutowireCapableBeanFactory.class protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123; if (bw == null) &#123; if (mbd.hasPropertyValues()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;); &#125; &#125; else &#123; boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; this.hasInstantiationAwareBeanPostProcessors()) &#123; Iterator var5 = this.getBeanPostProcessors().iterator(); while(var5.hasNext()) &#123; BeanPostProcessor bp = (BeanPostProcessor)var5.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; //如果后置处理器存在且其中任何一个的 postProcessAfterInstantiation 方法返回 false，则中断属性注入过程。 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (continueWithPropertyPopulation) &#123; PropertyValues pvs = mbd.hasPropertyValues() ? mbd.getPropertyValues() : null; if (mbd.getResolvedAutowireMode() == 1 || mbd.getResolvedAutowireMode() == 2) &#123; MutablePropertyValues newPvs = new MutablePropertyValues((PropertyValues)pvs); if (mbd.getResolvedAutowireMode() == 1) &#123; this.autowireByName(beanName, mbd, bw, newPvs); &#125; if (mbd.getResolvedAutowireMode() == 2) &#123; this.autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; boolean hasInstAwareBpps = this.hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = mbd.getDependencyCheck() != 0; PropertyDescriptor[] filteredPds = null; if (hasInstAwareBpps) &#123; if (pvs == null) &#123; pvs = mbd.getPropertyValues(); &#125; Iterator var9 = this.getBeanPostProcessors().iterator(); while(var9.hasNext()) &#123; BeanPostProcessor bp = (BeanPostProcessor)var9.next(); if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp; PropertyValues pvsToUse = ibp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; if (filteredPds == null) &#123; filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; //执行postProcessProperties方法 pvsToUse = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; return; &#125; &#125; pvs = pvsToUse; &#125; &#125; &#125; if (needsDepCheck) &#123; if (filteredPds == null) &#123; filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; this.checkDependencies(beanName, mbd, filteredPds, (PropertyValues)pvs); &#125; if (pvs != null) &#123; //属性最终填充 this.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs); &#125; &#125; &#125; &#125; 3.初始化初始化前初始化前会处理Aware回调，执行invokeAwareMethods(beanName, bean)方法，使用 Aware 回调接口获取容器的名称、类加载器和工厂信息，以便在 bean 内部执行定制的逻辑。 然后执行BeanPostProcessor的postProcessBeforeInitialization方法，这允许开发人员在 bean 初始化前介入 bean 的创建过程，执行一些自定义逻辑，例如初始化前的数据校验。这是 Spring 容器提供的一个非常有用的扩展点，用于实现各种定制和增强功能。 初始化时实现InitializingBean的afterPropertiesSet()方法 执行自定义的初始化方法 初始化后执行BeanPostProcessor的postProcessAfterInitialization方法，可以进行AOP等操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113AbstractAutowireCapableBeanFactory.classprotected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(() -&gt; &#123; this.invokeAwareMethods(beanName, bean); return null; &#125;, this.getAccessControlContext()); &#125; else &#123; this.invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //执行BeanPostProcessor的postProcessBeforeInitialization方法 wrappedBean = this.applyBeanPostProcessorsBeforeInitialization(bean, beanName); &#125; try &#123; this.invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable var6) &#123; throw new BeanCreationException(mbd != null ? mbd.getResourceDescription() : null, beanName, &quot;Invocation of init method failed&quot;, var6); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = this.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; private void invokeAwareMethods(String beanName, Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware)bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ClassLoader bcl = this.getBeanClassLoader(); if (bcl != null) &#123; ((BeanClassLoaderAware)bean).setBeanClassLoader(bcl); &#125; &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware)bean).setBeanFactory(this); &#125; &#125; &#125; protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd) throws Throwable &#123; boolean isInitializingBean = bean instanceof InitializingBean; if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; if (System.getSecurityManager() != null) &#123; try &#123; AccessController.doPrivileged(() -&gt; &#123; ((InitializingBean)bean).afterPropertiesSet(); return null; &#125;, this.getAccessControlContext()); &#125; catch (PrivilegedActionException var6) &#123; throw var6.getException(); &#125; &#125; else &#123; //执行InitializingBean的afterPropertiesSet()方法 ((InitializingBean)bean).afterPropertiesSet(); &#125; &#125; if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) &#123; String initMethodName = mbd.getInitMethodName(); if (StringUtils.hasLength(initMethodName) &amp;&amp; (!isInitializingBean || !&quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; //执行自定义的方法 this.invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125; &#125;AbstractAutowireCapableBeanFactory.class public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; Object current; for(Iterator var4 = this.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) &#123; BeanPostProcessor processor = (BeanPostProcessor)var4.next(); current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) &#123; return result; &#125; &#125; return result; &#125; public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; Object current; for(Iterator var4 = this.getBeanPostProcessors().iterator(); var4.hasNext(); result = current) &#123; BeanPostProcessor processor = (BeanPostProcessor)var4.next(); current = processor.postProcessAfterInitialization(result, beanName); if (current == null) &#123; return result; &#125; &#125; return result; &#125; 4.销毁将所有容器中的单例bean相关信息移除，回调所有相关的后置处理器和bean的销毁方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void destroy() &#123; if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123; Iterator var1 = this.beanPostProcessors.iterator(); while(var1.hasNext()) &#123; DestructionAwareBeanPostProcessor processor = (DestructionAwareBeanPostProcessor)var1.next(); processor.postProcessBeforeDestruction(this.bean, this.beanName); &#125; &#125; if (this.invokeDisposableBean) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Invoking destroy() on bean with name &#x27;&quot; + this.beanName + &quot;&#x27;&quot;); &#125; try &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(() -&gt; &#123; ((DisposableBean)this.bean).destroy(); return null; &#125;, this.acc); &#125; else &#123; //实现DisposableBean接口的destoy()方法 ((DisposableBean)this.bean).destroy(); &#125; &#125; catch (Throwable var3) &#123; String msg = &quot;Invocation of destroy method failed on bean with name &#x27;&quot; + this.beanName + &quot;&#x27;&quot;; if (logger.isDebugEnabled()) &#123; logger.info(msg, var3); &#125; else &#123; logger.info(msg + &quot;: &quot; + var3); &#125; &#125; &#125; if (this.destroyMethod != null) &#123; this.invokeCustomDestroyMethod(this.destroyMethod); &#125; else if (this.destroyMethodName != null) &#123; Method methodToCall = this.determineDestroyMethod(this.destroyMethodName); if (methodToCall != null) &#123; //自定义的销毁方法 this.invokeCustomDestroyMethod(methodToCall); &#125; &#125; &#125; 链接 http://ulemony.github.io/posts/c7e03167.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://ulemony.github.io/tags/spring/"}]},{"title":"Spring循环依赖","slug":"Spring循环依赖","date":"2024-01-23T14:17:21.000Z","updated":"2024-01-23T16:39:16.179Z","comments":true,"path":"posts/a5d86a59.html","link":"","permalink":"http://ulemony.github.io/posts/a5d86a59.html","excerpt":"spring循环依赖AService里面有BService属性，BService里面有AService属性 12345678910111213141516171819202122232425260.creatingSet(&#x27;AService&#x27;)1.new Aservice() ---&gt; Aservice普通对象 ---&gt; 三级缓存singletonFactories&lt;aService,lambda(beanName,Aservice)&gt;2.填充bService属性 ---&gt;单例池Map ---&gt;找不到 创建BService 2.1 new BService() ---&gt; BService普通对象 2.2 添加aService属性 ---&gt; 单例池Map ---&gt;找不到 ---&gt; creatingSet ---&gt; AService循环依赖 ---&gt; 二级缓存---&gt; 三级缓存 ---&gt; lambda---&gt; 判断要不要AOP？---&gt; 提前进行AOP ---&gt; AService代理对象 ---&gt; 放入二级缓存,并且移除三级缓存的对象(不再需要lambda表达式) --------------&gt;AService普通对象 2.3 添加其他属性 2.4 其他步骤 2.5 放入单例池Map&lt;beanName, AService Bean对象&gt; 3.填充cService属性 创建CService 3.1 new CService() ---&gt; BService普通对象 3.2 添加aService属性 ---&gt; 单例池Map ---&gt;找不到 ---&gt; creatingSet ---&gt; AService循环依赖 ---&gt;第二级 3.3 添加其他属性 3.4 其他步骤 3.5 放入单例池Map&lt;beanName, AService Bean对象&gt; 4.其他步骤(AOP) ---&gt;AService 代理对象(?) ---&gt;判断是否提前进行了AOP若是则返回普通对象，否则进行AOP返回代理对象5.把二级缓存对象放入一级缓存单例池Map&lt;beanName, AService Bean对象&gt;，并移除二级缓存对象注意：普通对象没有值是一个半成品；Bean对象有值，是一个完整体 三级缓存第一级缓存：singletonObjects 单例池 保证bean对象的单例效果","text":"spring循环依赖AService里面有BService属性，BService里面有AService属性 12345678910111213141516171819202122232425260.creatingSet(&#x27;AService&#x27;)1.new Aservice() ---&gt; Aservice普通对象 ---&gt; 三级缓存singletonFactories&lt;aService,lambda(beanName,Aservice)&gt;2.填充bService属性 ---&gt;单例池Map ---&gt;找不到 创建BService 2.1 new BService() ---&gt; BService普通对象 2.2 添加aService属性 ---&gt; 单例池Map ---&gt;找不到 ---&gt; creatingSet ---&gt; AService循环依赖 ---&gt; 二级缓存---&gt; 三级缓存 ---&gt; lambda---&gt; 判断要不要AOP？---&gt; 提前进行AOP ---&gt; AService代理对象 ---&gt; 放入二级缓存,并且移除三级缓存的对象(不再需要lambda表达式) --------------&gt;AService普通对象 2.3 添加其他属性 2.4 其他步骤 2.5 放入单例池Map&lt;beanName, AService Bean对象&gt; 3.填充cService属性 创建CService 3.1 new CService() ---&gt; BService普通对象 3.2 添加aService属性 ---&gt; 单例池Map ---&gt;找不到 ---&gt; creatingSet ---&gt; AService循环依赖 ---&gt;第二级 3.3 添加其他属性 3.4 其他步骤 3.5 放入单例池Map&lt;beanName, AService Bean对象&gt; 4.其他步骤(AOP) ---&gt;AService 代理对象(?) ---&gt;判断是否提前进行了AOP若是则返回普通对象，否则进行AOP返回代理对象5.把二级缓存对象放入一级缓存单例池Map&lt;beanName, AService Bean对象&gt;，并移除二级缓存对象注意：普通对象没有值是一个半成品；Bean对象有值，是一个完整体 三级缓存第一级缓存：singletonObjects 单例池 保证bean对象的单例效果 第二级缓存：earlySingletonObjects 保证单例效果，但是此时的对象还不是完整体 第三级缓存：singletonFactories 打破循环 哪些情况spring不能解决循环依赖构造注入,spring无法解决这样的循环依赖，无法产生基本的普通对象 1234567891011121314151617@Componentpublic class AService()&#123; public BService bService; @Autowired public AService(BService bService)&#123; this.bService=bService; &#125;&#125;@Componentpublic class BService()&#123; public AService aService; @Autowired public BService(AService aService)&#123; this.aService=aService; &#125;&#125; 针对上述情况需要用@Lazy注解来解决，会产生一个BService的代理对象,不会进入对BService属性赋值的逻辑 123456789101112131415161718@Componentpublic class AService()&#123; public BService bService; @Autowired @Lazy public AService(BService bService)&#123; //BService代理对象 this.bService=bService; &#125;&#125;@Componentpublic class BService()&#123; public AService aService; @Autowired public BService(AService aService)&#123; this.aService=aService; &#125;&#125; 源码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176AbstractAutowireCapableBeanFactory.class protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; instanceWrapper = this.createBeanInstance(beanName, mbd, args); &#125; Object bean = instanceWrapper.getWrappedInstance(); Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) &#123; mbd.resolvedTargetType = beanType; &#125; synchronized(mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; this.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable var17) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Post-processing of merged bean definition failed&quot;, var17); &#125; mbd.postProcessed = true; &#125; &#125; boolean earlySingletonExposure = mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; this.isSingletonCurrentlyInCreation(beanName); if (earlySingletonExposure) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName + &quot;&#x27; to allow for resolving potential circular references&quot;); &#125; //如果支持循环依赖，则生成三级缓存，提前暴露bean this.addSingletonFactory(beanName, () -&gt; &#123; return this.getEarlyBeanReference(beanName, mbd, bean); &#125;); &#125; Object exposedObject = bean; try &#123; //填充属性，循环依赖在这个阶段产生 this.populateBean(beanName, mbd, instanceWrapper); //执行初始化方法 exposedObject = this.initializeBean(beanName, exposedObject, mbd); &#125; catch (Throwable var18) &#123; if (var18 instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var18).getBeanName())) &#123; throw (BeanCreationException)var18; &#125; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, var18); &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = this.getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; //把原始bean 置换为代理对象 exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; this.hasDependentBean(beanName)) &#123; String[] dependentBeans = this.getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet(dependentBeans.length); String[] var12 = dependentBeans; int var13 = dependentBeans.length; for(int var14 = 0; var14 &lt; var13; ++var14) &#123; String dependentBean = var12[var14]; if (!this.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + &quot;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using &#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;); &#125; &#125; &#125; &#125; try &#123; this.registerDisposableBeanIfNecessary(beanName, bean, mbd); return exposedObject; &#125; catch (BeanDefinitionValidationException var16) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, var16); &#125; &#125;DefaultSingletonBeanRegistry.class @Nullable protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; //首先从一级缓存里面获取对象 Object singletonObject = this.singletonObjects.get(beanName); //一级缓存找不到而且对象正在创建中 if (singletonObject == null &amp;&amp; this.isSingletonCurrentlyInCreation(beanName)) &#123; //加锁 synchronized(this.singletonObjects) &#123; //从二级缓存找 singletonObject = this.earlySingletonObjects.get(beanName); //二级缓存找不到，并且允许循环依赖 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; //从三级缓存找到一个lambda表达式，实质是一个对象工厂 ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; //执行三级缓存里的lambda表达式，通过工厂方法来创建对象 singletonObject = singletonFactory.getObject(); //把创建的对象放入二级缓存中 this.earlySingletonObjects.put(beanName, singletonObject); //并且移除三级缓存的普通对象 this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject; &#125; public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, &quot;Bean name must not be null&quot;); synchronized(this.singletonObjects) &#123; Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; if (this.singletonsCurrentlyInDestruction) &#123; throw new BeanCreationNotAllowedException(beanName, &quot;Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;); &#125; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;Creating shared instance of singleton bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; // 标记bean创建中 this.beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = this.suppressedExceptions == null; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = new LinkedHashSet(); &#125; try &#123; singletonObject = singletonFactory.getObject(); newSingleton = true; &#125; catch (IllegalStateException var16) &#123; singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; throw var16; &#125; &#125; catch (BeanCreationException var17) &#123; BeanCreationException ex = var17; if (recordSuppressedExceptions) &#123; Iterator var8 = this.suppressedExceptions.iterator(); while(var8.hasNext()) &#123; Exception suppressedException = (Exception)var8.next(); ex.addRelatedCause(suppressedException); &#125; &#125; throw ex; &#125; finally &#123; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = null; &#125; this.afterSingletonCreation(beanName); &#125; if (newSingleton) &#123; this.addSingleton(beanName, singletonObject); &#125; &#125; return singletonObject; &#125; &#125; 三级缓存里lambda表达式的工厂方法 1234567891011121314151617protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123; Object exposedObject = bean; //会判断是否需要提前AOP 如果是则返回代理对象，否则直接返回普通对象 if (!mbd.isSynthetic() &amp;&amp; this.hasInstantiationAwareBeanPostProcessors()) &#123; Iterator var5 = this.getBeanPostProcessors().iterator(); while(var5.hasNext()) &#123; BeanPostProcessor bp = (BeanPostProcessor)var5.next(); if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123; SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor)bp; exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName); &#125; &#125; &#125; return exposedObject; &#125; 链接 http://ulemony.github.io/posts/a5d86a59.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://ulemony.github.io/tags/spring/"}]},{"title":"SpringBoot整合Redis","slug":"SpringBoot整合Redis","date":"2024-01-23T14:14:44.000Z","updated":"2024-01-23T17:39:11.772Z","comments":true,"path":"posts/4ebad2d4.html","link":"","permalink":"http://ulemony.github.io/posts/4ebad2d4.html","excerpt":"SpringBoot整合RedisPom依赖123456789101112131415161718192021&lt;dependencies&gt; &lt;!--集成redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--序列化--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok,自动生成set、get等方法--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 自定义封装RedisTemplate1234567891011121314151617181920212223242526272829303132333435363738import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(&quot;all&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; // 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); // Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // String 的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125;","text":"SpringBoot整合RedisPom依赖123456789101112131415161718192021&lt;dependencies&gt; &lt;!--集成redis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.1.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--序列化--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.54&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok,自动生成set、get等方法--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 自定义封装RedisTemplate1234567891011121314151617181920212223242526272829303132333435363738import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(&quot;all&quot;) public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; // 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); // Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // String 的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; &#125;&#125; RedisUtils类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import javax.annotation.Resource;import java.util.Collection;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;@Componentpublic final class RedisUtil &#123; @Resource private RedisTemplate&lt;String, Object&gt; redisTemplate; public Set&lt;String&gt; keys(String keys)&#123; try &#123; return redisTemplate.keys(keys); &#125;catch (Exception e)&#123; e.printStackTrace(); return null; &#125; &#125; /** * 指定缓存失效时间 * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据key 获取过期时间 * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key) &#123; return redisTemplate.getExpire(key, TimeUnit.SECONDS); &#125; /** * 判断key是否存在 * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key) &#123; try &#123; return redisTemplate.hasKey(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除缓存 * @param key 可以传一个值 或多个 */ @SuppressWarnings(&quot;unchecked&quot;) public void del(String... key) &#123; if (key != null &amp;&amp; key.length &gt; 0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key)); &#125; &#125; &#125; /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入, 不存在放入，存在返回 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean setnx(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().setIfAbsent(key,value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间,不存在放入，存在返回 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean setnx(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().setIfAbsent(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 递增 * @param key 键 * @param delta 要增加几(大于0) * @return */ public long incr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(&quot;递增因子必须大于0&quot;); &#125; return redisTemplate.opsForValue().increment(key, delta); &#125; /** * 递减 * @param key 键 * @param delta 要减少几(小于0) * @return */ public long decr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(&quot;递减因子必须大于0&quot;); &#125; return redisTemplate.opsForValue().increment(key, -delta); &#125; /** * HashGet * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key, String item) &#123; return redisTemplate.opsForHash().get(key, item); &#125; /** * 获取hashKey对应的所有键值 * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object, Object&gt; hmget(String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * HashSet * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * HashSet 并设置时间 * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value, long time) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除hash表中的值 * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item) &#123; redisTemplate.opsForHash().delete(key, item); &#125; /** * 判断hash表中是否有该项的值 * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item) &#123; return redisTemplate.opsForHash().hasKey(key, item); &#125; /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, by); &#125; /** * hash递减 * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, -by); &#125; /** * 根据key获取Set中的所有值 * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key) &#123; try &#123; return redisTemplate.opsForSet().members(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 根据value从一个set中查询,是否存在 * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key, Object value) &#123; try &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将数据放入set缓存 * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object... values) &#123; try &#123; return redisTemplate.opsForSet().add(key, values); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 将set数据放入缓存 * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key, long time, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().add(key, values); if (time &gt; 0)&#123; expire(key, time); &#125; return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 获取set缓存的长度 * @param key 键 * @return */ public long sGetSetSize(String key) &#123; try &#123; return redisTemplate.opsForSet().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 移除值为value的 * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().remove(key, values); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; // ===============================list================================= /** * 获取list缓存的内容 * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end) &#123; try &#123; return redisTemplate.opsForList().range(key, start, end); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 获取list缓存的长度 * @param key 键 * @return */ public long lGetListSize(String key) &#123; try &#123; return redisTemplate.opsForList().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 通过索引 获取list中的值 * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key, long index) &#123; try &#123; return redisTemplate.opsForList().index(key, index); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, Object value) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0)&#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List&lt;Object&gt; value) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0)&#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据索引修改list中的某条数据 * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index, Object value) &#123; try &#123; redisTemplate.opsForList().set(key, index, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 移除N个值为value * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key, long count, Object value) &#123; try &#123; Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125;&#125; 链接 http://ulemony.github.io/posts/4ebad2d4.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://ulemony.github.io/tags/redis/"}]},{"title":"Redis基础","slug":"Redis基础","date":"2024-01-23T14:10:52.000Z","updated":"2024-01-23T16:30:08.464Z","comments":true,"path":"posts/fe29e710.html","link":"","permalink":"http://ulemony.github.io/posts/fe29e710.html","excerpt":"Redis基础Redis五大数据类型String添加 1set key value","text":"Redis基础Redis五大数据类型String添加 1set key value 查询 1get key 查询当前库所有数据 1keys * 判断某个key是否存在，存在返回1，不存在返回0 1EXISTS key 对key的值追加拼接数据 1APPEND key value 查看数据长度 1STRLEN key 递增数值, 应用场景：网站访问次数，收藏数 12INCR keyINCRBY key num 指定数值递增 递减数值 12DECR keyDECRBY key num 指定数值递减 截取 1GETRANGE key 0 4 获取字符串下标从0开始，包含下标4 替换 1SETRANGE key 5 88 把下标为5的元素替换为88 同时设置&#x2F;获取多个键值对 12MSET key value [key value...] 设置MGET key [key...] 获取 分布式锁 1234567SETNX key value 不存在才设置SET key value [EX seconds] [PX milliseconds] [NX|XX]EX：key在多少秒之后过期PX：key在多少毫秒之后过期NX：当key不存在的时候，才创建key，效果等同于setnxXX：当key存在的时候，覆盖key list左添加 1LPUSH key value[value...] 右添加 1RPUSH key value[value...] 查看列表 1LRANGE key start stop 获取列表元素个数 1LLEN key 左移除 1lpop key 右移除 1rpop key 查询指定下标元素 1lindex key 1 查询下标为1的元素 移除 1lrem key 3 v2 移除集合中元素“v2”的元素3个 截取 1ltrim key start stop 只保留截取后的元素【start，stop】 更新 1lset key index newValue 将下标为index的元素更新为新值 hash相当于Java中Map&lt;String,Map&lt;object,object&gt;&gt; 123456应用场景：购物车新增商品 hset shopcar:uid1024 334488 1新增商品 hset shopcar:uid1024 334477 1增加商品数量 hincrby shopcar:uid1024 334477 1商品总数 hlen shopcar:uid1024全部选择 hgetall shopcar:uid1024 添加 12hset key field 添加一个hmset key field value[field value] 添加多个 查询 12hget key fieldhmget key field[field] 删除 1hdel key field[field] 获取长度 1hlen key 判断是否存在 1hexists key field 获取指定hash中所有key 1hkeys key 获取指定hash中所有value 1hvals key 增加 1hincrby key field increment Set无序；应用场景：抽奖、朋友圈点赞、社交关系、可能认识的人 添加 1sadd key member [member] 删除 1srem key member 获取所有元素 1smembers key 判断元素是否在集合中 1sismember key member 获取元素个数 1scard key 随机弹出元素，但不删除 1srandmember key [count] 随机弹出元素并删除 1spop key [count] 集合运算 123sinter key [key] 交集sdiff key [key] 差集sunion key [key] 并集 zset有序；应用场景：热搜、商品排序 添加 1zadd key score member [score member] 排序小-大 1zrange key start stop [withscores] 获取指定分数范围元素 12345zrangebyscore key min max [withscores] [limit offset count]min 和 max: 这两个参数用于指定分数范围的下限和上限，你可以使用 -inf 表示负无穷大，+inf 表示正无穷大。指定范围内的成员将会被检索。[withscores]: 这是一个可选参数，如果包含这个参数，那么返回的结果将包括成员的分数。如果不包含这个参数，只会返回成员的值。[limit offset count]: 这也是一个可选参数，用于限制返回的结果数量。offset 表示从匹配到的成员列表中的第几个成员开始返回结果，count 表示最多返回的成员数量。这个参数允许你进行分页查询，从匹配的成员中获取一部分。 增加某个元素分数 1zincrby key increment member 获取集合元素个数 1zcard key 获取指定范围元素个数 1zcount key min max 删除元素 1zrem key member [member] 按照排名范围删除元素 1zremrangebyrank key start stop 获取元素排名 12zrank key member 小-大zrevrank key member 大-小 链接 http://ulemony.github.io/posts/fe29e710.html","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ulemony.github.io/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://ulemony.github.io/tags/redis/"}]},{"title":"Docker常见命令","slug":"Docker常见命令","date":"2024-01-23T14:01:36.000Z","updated":"2024-01-23T14:42:44.542Z","comments":true,"path":"posts/a70288e8.html","link":"","permalink":"http://ulemony.github.io/posts/a70288e8.html","excerpt":"Docker常见命令添加阿里云镜像 1sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装命令 1sudo yum install -y docker-ce docker-ce-cli containerd.io","text":"Docker常见命令添加阿里云镜像 1sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装命令 1sudo yum install -y docker-ce docker-ce-cli containerd.io 启动命令 1sudo systemctl start docker 添加当前用户到docker用户组： 123sudo usermod -aG docker $USER （需注销）newgrp docker （立即生效） pull nginx 镜像 1docker pull nginx（等效于nginx:latest） 运行 1docker run -【d】（后台运行不阻塞shell） 【-p 80:80】（指定容器端口映射，内部：外部） nginx 查看正在运行 1docker ps 查看本地容器ID 1docker ps -a 删除容器 1docker rm -f &lt;container id(不用打全，前缀区分)&gt; 进入bash 1docker exec -it &lt;container id(不用打全，前缀区分)&gt; bash commit镜像 1docker commit &lt;container id(不用打全，前缀区分)&gt; &lt;name&gt; 查看镜像列表 1docker images （刚才commit的镜像） 使用运行刚才commit的镜像 1docker run -d &lt;name&gt; 使用Dockerfile构建镜像 1docker build -t &lt;name&gt; &lt;存放Dockerfile的文件夹&gt; 删除镜像 1docker rmi &lt;name&gt; 保存为tar 1docker save &lt;name&gt; &gt; &lt;tar name&gt; 从tar加载 1docker load &lt; &lt;tar name&gt; 一些启动参数： 1234567后台运行容器：-d容器内外端口映射：-p 内部端口号:外部端口号目录映射：-v &#x27;dir name&#x27; : &lt;dir&gt;指定映像版本：&lt;name&gt;:&lt;ver&gt; Docker容器中的文件拷贝至本地 #格式 docker cp CONTAINER ID:容器目录 本地目录 1sudo docker cp 52ea915e6527:/aha /home/aha2 本地文件拷贝至容器 #格式 docker cp 本地路径 CONTAINER ID:容器目录 1docker cp license.dat 52ea915e6527:/home 链接 http://ulemony.github.io/posts/a70288e8.html","categories":[{"name":"容器","slug":"容器","permalink":"http://ulemony.github.io/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://ulemony.github.io/tags/docker/"}]},{"title":"Dockerfile用法","slug":"Dockerfile用法","date":"2024-01-23T13:56:02.000Z","updated":"2024-01-23T14:42:44.529Z","comments":true,"path":"posts/387270af.html","link":"","permalink":"http://ulemony.github.io/posts/387270af.html","excerpt":"Dockerfile用法常见配置From XXX（基于什么镜像）WORKDIR（指定shell语句运行在那个路径下）COPY（将宿主机的文件拷贝到某路径下）RUN（运行shell语句，只要构建就会运行，如echo 321 &gt;&gt; 1.txt）CMD （指定镜像启动运行的脚本，只有容器真正运行的时候才会运行的脚本，执行后容器的生命周期即结束，且一般为阻塞式语句，如tail语句） 一般语句为：FROM WORKDIR COPY-ADD RUN CMD-ENTRYPOINTENTRYPOINT非json则以ENTRYPOT为准，如果ENTRYPOINT和CMD都是JSON则ENTRYPOINT+CMD拼接成shell EXPOSE—暴露镜像的指定端口VOLUME—指定映射文件ENV—指定doker的环境变量，运行时一直生效ARG—构建参数，运行时无效，可以构建时候临时修改变量LABEL—指定元数据，便于找到dockerONBUILD—当前镜像构建的时候不会执行，基于当前镜像的镜像去构建的时候才会执行STOPSIGNAL—指定容器使用什么信号，一般指定信号名HEALTHCHECK—检查容易的健康状态SHELL—指定linux为&#x2F;bin&#x2F;sh，windows为cmd","text":"Dockerfile用法常见配置From XXX（基于什么镜像）WORKDIR（指定shell语句运行在那个路径下）COPY（将宿主机的文件拷贝到某路径下）RUN（运行shell语句，只要构建就会运行，如echo 321 &gt;&gt; 1.txt）CMD （指定镜像启动运行的脚本，只有容器真正运行的时候才会运行的脚本，执行后容器的生命周期即结束，且一般为阻塞式语句，如tail语句） 一般语句为：FROM WORKDIR COPY-ADD RUN CMD-ENTRYPOINTENTRYPOINT非json则以ENTRYPOT为准，如果ENTRYPOINT和CMD都是JSON则ENTRYPOINT+CMD拼接成shell EXPOSE—暴露镜像的指定端口VOLUME—指定映射文件ENV—指定doker的环境变量，运行时一直生效ARG—构建参数，运行时无效，可以构建时候临时修改变量LABEL—指定元数据，便于找到dockerONBUILD—当前镜像构建的时候不会执行，基于当前镜像的镜像去构建的时候才会执行STOPSIGNAL—指定容器使用什么信号，一般指定信号名HEALTHCHECK—检查容易的健康状态SHELL—指定linux为&#x2F;bin&#x2F;sh，windows为cmd Demo12345678FROM alpineLABEl k=&quot;v&quot; k1=&quot;v1&quot;WORKDIR /appCOPY src/ /appRUN echo helloword &gt;&gt; 1.txtARG B=11ONBUILD ENV C=100CMD echo $C 构建镜像使用Dockerfile构建镜像：docker build -t &lt;存放Dockerfile的文件夹&gt; 例如：在当前文件夹构建名为test的镜像 1docker build -t test . 链接 http://ulemony.github.io/posts/387270af.html","categories":[{"name":"容器","slug":"容器","permalink":"http://ulemony.github.io/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://ulemony.github.io/tags/docker/"}]},{"title":"Jvm指令和工具","slug":"Jvm指令和工具","date":"2024-01-23T13:37:18.000Z","updated":"2024-01-23T16:39:03.844Z","comments":true,"path":"posts/817f8310.html","link":"","permalink":"http://ulemony.github.io/posts/817f8310.html","excerpt":"Jvm指令和工具jps 查看java进程 123lee@lee-mac ~ % jps63266 miniLegionInit.jar63964 Jps jconsole","text":"Jvm指令和工具jps 查看java进程 123lee@lee-mac ~ % jps63266 miniLegionInit.jar63964 Jps jconsoleJava监视和管理平台 1jconsole jstat查看内存 常用命令112345678910111213141516jstat -gcutil pid intervalpid:进程interval: 间隔时间lee@lee-mac ~ % jstat -gcutil 63266 1000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 0.00 0.00 88.29 14.70 95.12 93.41 10 0.079 2 0.202 0.281 常用命令21234jstat -gc pidlee@lee-mac ~ % jstat -gc 63266 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 6656.0 7680.0 0.0 0.0 71680.0 63287.4 90624.0 13323.2 35496.0 33765.1 4608.0 4304.3 10 0.079 2 0.202 0.281 常用命令31234jstat -gcnew pidlee@lee-mac ~ % jstat -gcnew 63266 S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT 6656.0 7680.0 0.0 0.0 1 15 7680.0 71680.0 63287.4 10 0.079 常用命令41234jstat -gcold pidlee@lee-mac ~ % jstat -gcold 63266 MC MU CCSC CCSU OC OU YGC FGC FGCT GCT 35496.0 33765.1 4608.0 4304.3 90624.0 13323.2 10 2 0.202 0.281 jstack分析线程运行状况 1jstack pid 但是jconsole已经集成jstack和jstat的功能 jmap可以把堆情况dump下来 然后用软件查看文件信息 123jmap -dump:file=a pid例如jmap -dump:file=a 63266 打印当前进程堆内存信息 1jmap -heap pid VisualVMjava虚拟机监控工具 启动1.进入jdk安装目录的bin目录，双击打开jvisualvm 2.终端模式下输入命令 1jvisualvm 链接 http://ulemony.github.io/posts/817f8310.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://ulemony.github.io/tags/jvm/"}]},{"title":"springsecurity之@PreAuthorize讲解","slug":"springsecurity之-PreAuthorize讲解","date":"2024-01-22T02:37:45.000Z","updated":"2024-01-23T16:39:10.998Z","comments":true,"path":"posts/9d7a9baf.html","link":"","permalink":"http://ulemony.github.io/posts/9d7a9baf.html","excerpt":"@PreAuthorize注解使用讲解@PreAuthorize 可以在方法前进行权限验证，如果没有对应权限则无法执行方法，下面是使用案例 a.在对应方法使用@PreAuthorize注解，值为EL表达式123456@ApiOperation(&quot;导出用户数据&quot;)@GetMapping(value = &quot;/download&quot;)@PreAuthorize(&quot;@el.check(&#x27;user:list&#x27;)&quot;)public void exportUser(HttpServletResponse response, UserQueryCriteria criteria) throws IOException &#123; userService.download(userService.queryAll(criteria), response);&#125; b.在SpringSecurityConfig上使用注解@EnableGlobalMethodSecurity","text":"@PreAuthorize注解使用讲解@PreAuthorize 可以在方法前进行权限验证，如果没有对应权限则无法执行方法，下面是使用案例 a.在对应方法使用@PreAuthorize注解，值为EL表达式123456@ApiOperation(&quot;导出用户数据&quot;)@GetMapping(value = &quot;/download&quot;)@PreAuthorize(&quot;@el.check(&#x27;user:list&#x27;)&quot;)public void exportUser(HttpServletResponse response, UserQueryCriteria criteria) throws IOException &#123; userService.download(userService.queryAll(criteria), response);&#125; b.在SpringSecurityConfig上使用注解@EnableGlobalMethodSecurity123456@Configuration@EnableWebSecurity@RequiredArgsConstructor//开启prePostEnabled和securedEnabled@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)public class SpringSecurityConfig extends WebSecurityConfigurerAdapter &#123; c.对el表达式进行处理12345678910@Service(value = &quot;el&quot;)public class AuthorityConfig &#123; public Boolean check(String ...permissions)&#123; // 获取当前用户的所有权限 List&lt;String&gt; elPermissions = SecurityUtils.getCurrentUser().getAuthorities().stream().map(GrantedAuthority::getAuthority).collect(Collectors.toList()); // 判断当前用户为admin或者含有对应权限则验证通过 return elPermissions.contains(&quot;admin&quot;) || Arrays.stream(permissions).anyMatch(elPermissions::contains); &#125;&#125; @PreAuthorize源码讲解首先看该注解的代码 1234567@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface PreAuthorize &#123; String value();&#125; 该注解并不能直接进行权限验证，那它是怎么生效的呢？主要靠注解@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true, securedEnabled &#x3D; true)，它通过Import导入了GlobalMethodSecuritySelector.class，而在这个类中注册了GlobalMethodSecurityConfiguration.class GlobalMethodSecuritySelector.class关键源码1234567891011121314151617181920212223242526272829303132333435final class GlobalMethodSecuritySelector implements ImportSelector &#123; GlobalMethodSecuritySelector() &#123; &#125; public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; Class&lt;EnableGlobalMethodSecurity&gt; annoType = EnableGlobalMethodSecurity.class; Map&lt;String, Object&gt; annotationAttributes = importingClassMetadata.getAnnotationAttributes(annoType.getName(), false); AnnotationAttributes attributes = AnnotationAttributes.fromMap(annotationAttributes); Assert.notNull(attributes, () -&gt; &#123; return String.format(&quot;@%s is not present on importing class &#x27;%s&#x27; as expected&quot;, annoType.getSimpleName(), importingClassMetadata.getClassName()); &#125;); Class&lt;?&gt; importingClass = ClassUtils.resolveClassName(importingClassMetadata.getClassName(), ClassUtils.getDefaultClassLoader()); boolean skipMethodSecurityConfiguration = GlobalMethodSecurityConfiguration.class.isAssignableFrom(importingClass); AdviceMode mode = (AdviceMode)attributes.getEnum(&quot;mode&quot;); boolean isProxy = AdviceMode.PROXY == mode; String autoProxyClassName = isProxy ? AutoProxyRegistrar.class.getName() : GlobalMethodSecurityAspectJAutoProxyRegistrar.class.getName(); boolean jsr250Enabled = attributes.getBoolean(&quot;jsr250Enabled&quot;); List&lt;String&gt; classNames = new ArrayList(4); if (isProxy) &#123; classNames.add(MethodSecurityMetadataSourceAdvisorRegistrar.class.getName()); &#125; classNames.add(autoProxyClassName); if (!skipMethodSecurityConfiguration) &#123; //注册了GlobalMethodSecurityConfiguration.class classNames.add(GlobalMethodSecurityConfiguration.class.getName()); &#125; if (jsr250Enabled) &#123; classNames.add(Jsr250MetadataSourceConfiguration.class.getName()); &#125; return (String[])classNames.toArray(new String[0]); &#125;&#125; GlobalMethodSecurityConfiguration.class关键源码这个类非常关键，负责生成权限验证所需要的拦截器、权限管理器、EL表达式处理器 123456789101112131415161718192021222324252627282930313233343536373839404142GlobalMethodSecurityConfiguration.class @Beanpublic MethodInterceptor methodSecurityInterceptor(MethodSecurityMetadataSource methodSecurityMetadataSource) &#123; this.methodSecurityInterceptor = (MethodSecurityInterceptor)(this.isAspectJ() ? new AspectJMethodSecurityInterceptor() : new MethodSecurityInterceptor()); //设置访问决策管理器 this.methodSecurityInterceptor.setAccessDecisionManager(this.accessDecisionManager()); this.methodSecurityInterceptor.setAfterInvocationManager(this.afterInvocationManager()); //设置安全元数据源 用于获取方法级别的安全性配置信息 this.methodSecurityInterceptor.setSecurityMetadataSource(methodSecurityMetadataSource); RunAsManager runAsManager = this.runAsManager(); if (runAsManager != null) &#123; this.methodSecurityInterceptor.setRunAsManager(runAsManager); &#125; return this.methodSecurityInterceptor;&#125;//这段代码的作用是根据配置创建一个 AccessDecisionManager 实例，并配置其中的访问决策投票者。这些投票者负责根据不同的投票逻辑，决定用户是否有权限执行某个方法 protected AccessDecisionManager accessDecisionManager() &#123; List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters = new ArrayList();//@EnableGlobalMethodSecurity注解需要开启prePostEnabled = true,如果启用了 Pre-Post 注解（@PreAuthorize 和 @PostAuthorize），则创建并添加一个基于表达式的 Pre-Invocation 投票者 if (this.prePostEnabled()) &#123; ExpressionBasedPreInvocationAdvice expressionAdvice = new ExpressionBasedPreInvocationAdvice(); //获取El表达式处理器 expressionAdvice.setExpressionHandler(this.getExpressionHandler()); decisionVoters.add(new PreInvocationAuthorizationAdviceVoter(expressionAdvice)); &#125; if (this.jsr250Enabled()) &#123; decisionVoters.add(new Jsr250Voter()); &#125; RoleVoter roleVoter = new RoleVoter(); GrantedAuthorityDefaults grantedAuthorityDefaults = (GrantedAuthorityDefaults)this.getSingleBeanOrNull(GrantedAuthorityDefaults.class); if (grantedAuthorityDefaults != null) &#123; roleVoter.setRolePrefix(grantedAuthorityDefaults.getRolePrefix()); &#125; decisionVoters.add(roleVoter); decisionVoters.add(new AuthenticatedVoter()); //这些投票者被组合到 AffirmativeBased 决策管理器中。 return new AffirmativeBased(decisionVoters); &#125; 权限生效源码分析上面介绍了和权限相关的核心类，下面分析权限验证是怎么生效的 a. 获取安全元数据信息首先执行MethodSecurityInterceptor 父类AbstractSecurityInterceptor的beforeInvocation方法获取安全元数据信息 123AbstractSecurityInterceptor.class Collection&lt;ConfigAttribute&gt; attributes = this.obtainSecurityMetadataSource().getAttributes(object); 由PrePostAnnotationSecurityMetadataSource 类进行获取 1234567891011121314151617PrePostAnnotationSecurityMetadataSource.class public Collection&lt;ConfigAttribute&gt; getAttributes(Method method, Class&lt;?&gt; targetClass) &#123; if (method.getDeclaringClass() == Object.class) &#123; return Collections.emptyList(); &#125; else &#123; PreFilter preFilter = (PreFilter)this.findAnnotation(method, targetClass, PreFilter.class); //处理注解@PreAuthorize PreAuthorize preAuthorize = (PreAuthorize)this.findAnnotation(method, targetClass, PreAuthorize.class); PostFilter postFilter = (PostFilter)this.findAnnotation(method, targetClass, PostFilter.class); PostAuthorize postAuthorize = (PostAuthorize)this.findAnnotation(method, targetClass, PostAuthorize.class); //.....省略代码 //返回元数据 格式如下[authorize: &#x27;@el.check()&#x27;, filter: &#x27;null&#x27;, filterTarget: &#x27;null&#x27;] return attrs; &#125; &#125;&#125; b.进行权限验证接着在beforeInvocation方法中调用attemptAuthorization方法 1234567891011121314151617AbstractSecurityInterceptor.class private void attemptAuthorization(Object object, Collection&lt;ConfigAttribute&gt; attributes, Authentication authenticated) &#123; try &#123;//利用AccessDecisionManager，也就是前面GlobalMethodSecurityConfiguration.class中配置的AffirmativeBased 决策管理器进行权限检验 this.accessDecisionManager.decide(authenticated, object, attributes); &#125; catch (AccessDeniedException var5) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace(LogMessage.format(&quot;Failed to authorize %s with attributes %s using %s&quot;, object, attributes, this.accessDecisionManager)); &#125; else if (this.logger.isDebugEnabled()) &#123; this.logger.debug(LogMessage.format(&quot;Failed to authorize %s with attributes %s&quot;, object, attributes)); &#125; this.publishEvent(new AuthorizationFailureEvent(object, attributes, authenticated, var5)); throw var5; &#125;&#125; c.决策管理器验证核心是voter执行vote方法进行投票 1234567891011121314151617181920212223242526272829public class AffirmativeBased extends AbstractAccessDecisionManager &#123; public AffirmativeBased(List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters) &#123; super(decisionVoters); &#125; public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException &#123; int deny = 0; Iterator var5 = this.getDecisionVoters().iterator(); while(var5.hasNext()) &#123; AccessDecisionVoter voter = (AccessDecisionVoter)var5.next(); //会利用PreInvocationAuthorizationAdviceVoter 进行投票 int result = voter.vote(authentication, object, configAttributes); switch(result) &#123; case -1: ++deny; break; case 1: return; &#125; &#125; if (deny &gt; 0) &#123; throw new AccessDeniedException(this.messages.getMessage(&quot;AbstractAccessDecisionManager.accessDenied&quot;, &quot;Access is denied&quot;)); &#125; else &#123; this.checkAllowIfAllAbstainDecisions(); &#125; &#125;&#125; d.EL表达式处理在PreInvocationAuthorizationAdviceVoter中执行vote方法，最终落实到自定义的el表达式处理逻辑 1234567891011PreInvocationAuthorizationAdviceVoter.class public int vote(Authentication authentication, MethodInvocation method, Collection&lt;ConfigAttribute&gt; attributes) &#123; PreInvocationAttribute preAttr = this.findPreInvocationAttribute(attributes); if (preAttr == null) &#123; return 0; &#125; else &#123; //调用before方法进入el表达式处理逻辑，如果返回true获得票数1 return this.preAdvice.before(authentication, method, preAttr) ? 1 : -1; &#125;&#125; 1234567891011121314ExpressionBasedPreInvocationAdvice.class //执行before方法public boolean before(Authentication authentication, MethodInvocation mi, PreInvocationAttribute attr) &#123; PreInvocationExpressionAttribute preAttr = (PreInvocationExpressionAttribute)attr; EvaluationContext ctx = this.expressionHandler.createEvaluationContext(authentication, mi); Expression preFilter = preAttr.getFilterExpression(); Expression preAuthorize = preAttr.getAuthorizeExpression(); if (preFilter != null) &#123; Object filterTarget = this.findFilterTarget(preAttr.getFilterTarget(), ctx, mi); this.expressionHandler.filter(filterTarget, preFilter, ctx); &#125;//进入自定义的el表达式处理逻辑，也就是上面AuthorityConfig 自定义的权限验证逻辑，如果有对应权限则返回true return preAuthorize != null ? ExpressionUtils.evaluateAsBoolean(preAuthorize, ctx) : true;&#125; e.投票结果回到上面的决策管理器AffirmativeBased 当投票结果result&#x3D;1时 直接return表示权限验证通过，否则++deny表示权限验证不通过，抛出AccessDeniedException异常，至此完成权限验证 12345678910111213141516171819202122232425AffirmativeBased.class public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException &#123; int deny = 0; Iterator var5 = this.getDecisionVoters().iterator(); while(var5.hasNext()) &#123; AccessDecisionVoter voter = (AccessDecisionVoter)var5.next(); // 当el表达式返回true时获得票数1否则为-1 int result = voter.vote(authentication, object, configAttributes); switch(result) &#123; case -1: ++deny; break; case 1: return; &#125; &#125;//deny大于0 表示权限验证不通过，抛出异常 if (deny &gt; 0) &#123; throw new AccessDeniedException(this.messages.getMessage(&quot;AbstractAccessDecisionManager.accessDenied&quot;, &quot;Access is denied&quot;)); &#125; else &#123; this.checkAllowIfAllAbstainDecisions(); &#125; &#125; 链接 http://ulemony.github.io/posts/9d7a9baf.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://ulemony.github.io/tags/SpringSecurity/"}]},{"title":"GPT-4体验","slug":"GPT-4体验","date":"2023-03-15T15:38:48.000Z","updated":"2023-03-15T17:30:50.000Z","comments":true,"path":"posts/e0a37648.html","link":"","permalink":"http://ulemony.github.io/posts/e0a37648.html","excerpt":"GPT-4今天openai发布了目前为止AI领域最先进的人工智能系统——GPT-4 于是申请注册体验，由于人太多，估计要等几个工作日，期待能通过申请 GPT-4可以做什么","text":"GPT-4今天openai发布了目前为止AI领域最先进的人工智能系统——GPT-4 于是申请注册体验，由于人太多，估计要等几个工作日，期待能通过申请 GPT-4可以做什么1.Creativity 创造力它可以生成、编辑和迭代用户进行创意和技术写作任务，例如创作歌曲、编写剧本或学习用户的写作风格。 例如我们输入要求让它解释灰姑娘的故事情节，它会根据要求生成相应的结果： 1234InputExplain the plot of Cinderella in a sentence where each word has to begin with the next letter in the alphabet from A to Z, without repeating any letters.用一个句子解释灰姑娘的情节，其中每个单词必须以字母表中从 A 到 Z 的下一个字母开头，不要重复任何字母 1234OutputA beautiful Cinderella, dwelling eagerly, finally gains happiness; inspiring jealous kin, love magically nurtures opulent prince; quietly rescues, slipper triumphs, uniting very wondrously, xenial youth zealously.美丽的灰姑娘，急切地栖息着，终于获得了幸福;激发嫉妒的亲人，爱情神奇地培育出华丽的王子;悄悄地营救，拖鞋胜利，团结得非常奇妙，青春热心。 这个功能对于写作辅助可谓一大利器，对于写论文、高考作文训练真是大大滴好呀！ 2.Visual input 图像输入GPT-4 根据输入的图像并生成标题、分类和分析，例如我们输入一张图片，询问它可以利用图片中的原材料做成什么食物 它会识别图片内容并给出建议：煎饼或华夫饼&#x2F;薄饼&#x2F;法式吐司&#x2F;煎蛋或煎蛋饼 （没有广东肠粉差评～-～） 如果你对有选择困难症，可以拍下自家的冰箱，让chatgt告诉你今天吃什么 PS：很好奇发一张九转大肠的图片给chatgt，它给的食谱会不会保留大肠原来的味道～-～ 3.Longer context 更长的文字处理GPT-4 能够处理超过 25，000 字的文本，允许使用长篇内容创建、扩展对话以及文档搜索和分析等用例。 打个比方，附上蕾哈娜的维基百科信息网址，让它分析蕾哈娜在超级碗中的表现以及过人之处： 1234Input[Text from: https://en.wikipedia.org/wiki/Rihanna]Describe her Super Bowl performance and what made it special. GPT-4会从长达几万字的维基百科介绍中提炼出如下结果： 123OutputRihanna&#x27;s Super Bowl LVII halftime show performance was special for a number of reasons. For one, it marked her first live performance in over five years, and it was her first time headlining the Super Bowl halftime show. Additionally, she made history by becoming the first person to perform at the Super Bowl while pregnant. The show itself was critically acclaimed, with many praising her high-energy performance and impressive vocals. It also garnered a massive viewership, becoming the second most-watched halftime show in history.蕾哈娜的超级碗LVII中场秀表演很特别，原因有很多。首先，这是她五年多来的第一次现场表演，这是她第一次在超级碗中场秀中担任头条新闻。此外，她创造了历史，成为第一个在怀孕期间在超级碗上表演的人。该节目本身广受好评，许多人称赞她的高能量表演和令人印象深刻的人声。它还获得了大量的收视率，成为历史上收视率第二高的中场秀。 GPT-4的亮点GPT-4在其先进的推理能力方面超过了上一个版本ChatGPT。 例如同一个问题，GPT-4比ChatGPT给出了更加精准的答案 123InputAndrew is free from 11 am to 3 pm, Joanne is free from noon to 2 pm and then 3:30 pm to 5 pm. Hannah is available at noon for half an hour, and then 4 pm to 6 pm. What are some options for start times for a 30 minute meeting for Andrew, Hannah, and Joanne?安德鲁从上午 11 点到下午 3 点有空，乔安妮从中午到下午 2 点，然后下午 3：30 到下午 5 点自由。汉娜在中午半小时可用，然后下午4点到6点。对于安德鲁、汉娜和乔安妮来说，30 分钟会议的开始时间有哪些选择？ ChatGPT给出的答案 12345678910111213OutputHere is a list of their availability:- Andrew: 11 am to 3 pm- Joanne: noon to 2 pm, and 3:30 pm to 5 pm- Hannah: noon to 12:30 pm, and 4 pm to 6 pmBased on their availability, there is a 30-minute window where all three of them are available, which is from 4 pm to 4:30 pm. So, the meeting can be scheduled at 4 pm.以下是它们的可用性列表：- 安德鲁：上午 11 点至下午 3 点- 乔安妮：中午至下午 2 点，下午 3：30 至下午 5 点- 汉娜：中午至下午 12：30，下午 4 点至下午 6 点根据他们的可用性，有一个 30 分钟的窗口，所有三个都可用，即下午 4 点到 4：30。因此，会议可以安排在下午 4 点。 GPT-4给出的答案 Andrew: 11 am - 3 pm Joanne: 12 pm - 2 pm, 3:30 pm - 5 pm Hannah: 12 pm - 12:30 pm, 4 pm - 6 pm Common availability for a 30-minute meeting: 12 pm - 12:30 pm安德鲁：上午 11 点至下午 3 点乔安妮：中午 12 点至下午 2 点，下午 3：30 至下午 5 点汉娜：中午12时至下午12时30分，下午4时至下午6时 30 分钟会议的通用可用性：中午 12 点至下午 12：30 人类未来的诗歌最后附上一首CHATGPT写的诗歌，人工智能在将会彻底颠覆人类社会的各个方面，希望这是写给人类的颂歌 链接 http://ulemony.github.io/posts/e0a37648.html","categories":[{"name":"AI","slug":"AI","permalink":"http://ulemony.github.io/categories/AI/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://ulemony.github.io/tags/ChatGPT/"}]},{"title":"Kafka常用命令","slug":"Kafka常用命令","date":"2023-02-10T15:46:45.000Z","updated":"2024-01-23T17:47:01.854Z","comments":true,"path":"posts/d25e2bb0.html","link":"","permalink":"http://ulemony.github.io/posts/d25e2bb0.html","excerpt":"进入容器 1docker exec -it 容器id bash 进入到kafka的安装目录，查看到kafka相关的命令 1cd /opt/kafka/bin/ topic操作","text":"进入容器 1docker exec -it 容器id bash 进入到kafka的安装目录，查看到kafka相关的命令 1cd /opt/kafka/bin/ topic操作创建一个topic12#添加名为test的topic 一个分区，3个副本,其中xxxx:2181为zookeeper的端口kafka-topics.sh --zookeeper xxxx:2181 --create --topic test --replication-factor 1 --partitions 3 执行后效果如下： 1Created topic test. 查询topic列表12#其中xxxx:2181为zookeeper的端口kafka-topics.sh --zookeeper xxxx:2181 --list 执行后效果如下 1test 查询topic详情12#查询名为test2的topic详情kafka-topics.sh --zookeeper xxxx:2181 --describe --topic test2 执行后效果如下 1234Topic: test2 TopicId: uly4F1d3SEyregeocjltZA PartitionCount: 3 ReplicationFactor: 1 Configs: Topic: test2 Partition: 0 Leader: 0 Replicas: 0 Isr: 0 Topic: test2 Partition: 1 Leader: 0 Replicas: 0 Isr: 0 Topic: test2 Partition: 2 Leader: 0 Replicas: 0 Isr: 0 删除topic12#删除名为test2的topickafka-topics.sh --zookeeper xxxx:2181 --delete --topic test2 执行后效果如下 12Topic test2 is marked for deletion.Note: This will have no impact if delete.topic.enable is not set to true. 发送消费消息生产者发送消息1kafka-console-producer.sh --broker-list localhost:9092 --topic example 执行后效果如下 12&gt;^Croot@f48c27085ce3:/opt/kafka/bin# kafka-console-producer.sh --broker-list localhost:9092 --topic example&gt;hello world！ 消费者消费消息1kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic example --from-beginning 执行后效果如下 1hello world！ 链接 http://ulemony.github.io/posts/d25e2bb0.html","categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"}],"tags":[{"name":"kafka'","slug":"kafka","permalink":"http://ulemony.github.io/tags/kafka/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2023-02-09T02:16:12.000Z","updated":"2023-02-09T07:14:10.000Z","comments":true,"path":"posts/d0edc1ed.html","link":"","permalink":"http://ulemony.github.io/posts/d0edc1ed.html","excerpt":"Linux常用命令文件管理使用scp将一个Linux系统中的文件或文件夹复制到另一台Linux服务器上 复制文件1.将本地文件拷贝到远程主机","text":"Linux常用命令文件管理使用scp将一个Linux系统中的文件或文件夹复制到另一台Linux服务器上 复制文件1.将本地文件拷贝到远程主机 123//scp 文件名 用户名@计算机IP或者计算机名称:远程路径//192.168.1.12为远程服务器scp /root/install.* root@192.168.1.12:/usr/local/src 2.从远程将文件拷回本地 123//scp 用户名@计算机IP或者计算机名称:文件名 本地路径//本地192.168.1.8客户端取远程服务器12、11上的文件scp root@192.168.1.12:/usr/local/src/*.log /root/ 复制目录1.将本地文件夹拷贝到远程 123//scp -r 目录名 用户名@计算机IP或者计算机名称:远程路径//test1为源目录，test2为目标目录，zhidao@192.168.0.1为远程服务器的用户名和ip地址。scp -r /home/test1 zhidao@192.168.0.1:/home/test2 2.从远程拷贝目录回本地 123//scp -r 用户名@计算机IP或者计算机名称:目录名 本地路径//zhidao@192.168.0.1为远程服务器的用户名和ip地址，test1为源目录，test2为目标目录scp -r zhidao@192.168.0.1:/home/test2 /home/test1 链接 http://ulemony.github.io/posts/d0edc1ed.html","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ulemony.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ulemony.github.io/tags/Linux/"},{"name":"文件操作","slug":"文件操作","permalink":"http://ulemony.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://ulemony.github.io/categories/Java/"},{"name":"Redis","slug":"Redis","permalink":"http://ulemony.github.io/categories/Redis/"},{"name":"容器","slug":"容器","permalink":"http://ulemony.github.io/categories/%E5%AE%B9%E5%99%A8/"},{"name":"AI","slug":"AI","permalink":"http://ulemony.github.io/categories/AI/"},{"name":"Linux","slug":"Linux","permalink":"http://ulemony.github.io/categories/Linux/"}],"tags":[{"name":"chatgpt","slug":"chatgpt","permalink":"http://ulemony.github.io/tags/chatgpt/"},{"name":"springboot","slug":"springboot","permalink":"http://ulemony.github.io/tags/springboot/"},{"name":"spring","slug":"spring","permalink":"http://ulemony.github.io/tags/spring/"},{"name":"redis","slug":"redis","permalink":"http://ulemony.github.io/tags/redis/"},{"name":"docker","slug":"docker","permalink":"http://ulemony.github.io/tags/docker/"},{"name":"jvm","slug":"jvm","permalink":"http://ulemony.github.io/tags/jvm/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://ulemony.github.io/tags/SpringSecurity/"},{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://ulemony.github.io/tags/ChatGPT/"},{"name":"kafka'","slug":"kafka","permalink":"http://ulemony.github.io/tags/kafka/"},{"name":"Linux","slug":"Linux","permalink":"http://ulemony.github.io/tags/Linux/"},{"name":"文件操作","slug":"文件操作","permalink":"http://ulemony.github.io/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]}